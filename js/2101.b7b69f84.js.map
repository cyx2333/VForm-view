{"version":3,"file":"js/2101.b7b69f84.js","mappings":"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","sources":["webpack://admin/./node_modules/ace-code/src/mode/c_cpp.js","webpack://admin/./node_modules/ace-code/src/mode/c_cpp_highlight_rules.js","webpack://admin/./node_modules/ace-code/src/mode/dart.js","webpack://admin/./node_modules/ace-code/src/mode/dart_highlight_rules.js","webpack://admin/./node_modules/ace-code/src/mode/doc_comment_highlight_rules.js","webpack://admin/./node_modules/ace-code/src/mode/folding/cstyle.js","webpack://admin/./node_modules/ace-code/src/mode/matching_brace_outdent.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar c_cppHighlightRules = require(\"./c_cpp_highlight_rules\").c_cppHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar CStyleFoldMode = require(\"./folding/cstyle\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = c_cppHighlightRules;\n\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n\n    this.foldingRules = new CStyleFoldMode();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n    this.lineCommentStart = \"//\";\n    this.blockComment = {start: \"/*\", end: \"*/\"};\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n        var endState = tokenizedLine.state;\n\n        if (tokens.length && tokens[tokens.length-1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            if (match) {\n                indent += tab;\n            }\n        } else if (state == \"doc-start\") {\n            if (endState == \"start\") {\n                return \"\";\n            }\n            var match = line.match(/^\\s*(\\/?)\\*/);\n            if (match) {\n                if (match[1]) {\n                    indent += \" \";\n                }\n                indent += \"* \";\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n\n    this.$id = \"ace/mode/c_cpp\";\n    this.snippetFileId = \"ace/snippets/c_cpp\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar DocCommentHighlightRules = require(\"./doc_comment_highlight_rules\").DocCommentHighlightRules;\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n// used by objective-c\nvar cFunctions = exports.cFunctions = \"hypot|hypotf|hypotl|sscanf|system|snprintf|scanf|scalbn|scalbnf|scalbnl|scalbln|scalblnf|scalblnl|sin|sinh|sinhf|sinhl|sinf|sinl|signal|signbit|strstr|strspn|strncpy|strncat|strncmp|strcspn|strchr|strcoll|strcpy|strcat|strcmp|strtoimax|strtod|strtoul|strtoull|strtoumax|strtok|strtof|strtol|strtold|strtoll|strerror|strpbrk|strftime|strlen|strrchr|strxfrm|sprintf|setjmp|setvbuf|setlocale|setbuf|sqrt|sqrtf|sqrtl|swscanf|swprintf|srand|nearbyint|nearbyintf|nearbyintl|nexttoward|nexttowardf|nexttowardl|nextafter|nextafterf|nextafterl|nan|nanf|nanl|csin|csinh|csinhf|csinhl|csinf|csinl|csqrt|csqrtf|csqrtl|ccos|ccosh|ccoshf|ccosf|ccosl|cimag|cimagf|cimagl|ctime|ctan|ctanh|ctanhf|ctanhl|ctanf|ctanl|cos|cosh|coshf|coshl|cosf|cosl|conj|conjf|conjl|copysign|copysignf|copysignl|cpow|cpowf|cpowl|cproj|cprojf|cprojl|ceil|ceilf|ceill|cexp|cexpf|cexpl|clock|clog|clogf|clogl|clearerr|casin|casinh|casinhf|casinhl|casinf|casinl|cacos|cacosh|cacoshf|cacoshl|cacosf|cacosl|catan|catanh|catanhf|catanhl|catanf|catanl|calloc|carg|cargf|cargl|cabs|cabsf|cabsl|creal|crealf|creall|cbrt|cbrtf|cbrtl|time|toupper|tolower|tan|tanh|tanhf|tanhl|tanf|tanl|trunc|truncf|truncl|tgamma|tgammaf|tgammal|tmpnam|tmpfile|isspace|isnormal|isnan|iscntrl|isinf|isdigit|isunordered|isupper|ispunct|isprint|isfinite|iswspace|iswcntrl|iswctype|iswdigit|iswupper|iswpunct|iswprint|iswlower|iswalnum|iswalpha|iswgraph|iswxdigit|iswblank|islower|isless|islessequal|islessgreater|isalnum|isalpha|isgreater|isgreaterequal|isgraph|isxdigit|isblank|ilogb|ilogbf|ilogbl|imaxdiv|imaxabs|div|difftime|_Exit|ungetc|ungetwc|pow|powf|powl|puts|putc|putchar|putwc|putwchar|perror|printf|erf|erfc|erfcf|erfcl|erff|erfl|exit|exp|exp2|exp2f|exp2l|expf|expl|expm1|expm1f|expm1l|vsscanf|vsnprintf|vscanf|vsprintf|vswscanf|vswprintf|vprintf|vfscanf|vfprintf|vfwscanf|vfwprintf|vwscanf|vwprintf|va_start|va_copy|va_end|va_arg|qsort|fscanf|fsetpos|fseek|fclose|ftell|fopen|fdim|fdimf|fdiml|fpclassify|fputs|fputc|fputws|fputwc|fprintf|feholdexcept|fesetenv|fesetexceptflag|fesetround|feclearexcept|fetestexcept|feof|feupdateenv|feraiseexcept|ferror|fegetenv|fegetexceptflag|fegetround|fflush|fwscanf|fwide|fwprintf|fwrite|floor|floorf|floorl|fabs|fabsf|fabsl|fgets|fgetc|fgetpos|fgetws|fgetwc|freopen|free|fread|frexp|frexpf|frexpl|fmin|fminf|fminl|fmod|fmodf|fmodl|fma|fmaf|fmal|fmax|fmaxf|fmaxl|ldiv|ldexp|ldexpf|ldexpl|longjmp|localtime|localeconv|log|log1p|log1pf|log1pl|log10|log10f|log10l|log2|log2f|log2l|logf|logl|logb|logbf|logbl|labs|lldiv|llabs|llrint|llrintf|llrintl|llround|llroundf|llroundl|lrint|lrintf|lrintl|lround|lroundf|lroundl|lgamma|lgammaf|lgammal|wscanf|wcsstr|wcsspn|wcsncpy|wcsncat|wcsncmp|wcscspn|wcschr|wcscoll|wcscpy|wcscat|wcscmp|wcstoimax|wcstod|wcstoul|wcstoull|wcstoumax|wcstok|wcstof|wcstol|wcstold|wcstoll|wcstombs|wcspbrk|wcsftime|wcslen|wcsrchr|wcsrtombs|wcsxfrm|wctob|wctomb|wcrtomb|wprintf|wmemset|wmemchr|wmemcpy|wmemcmp|wmemmove|assert|asctime|asin|asinh|asinhf|asinhl|asinf|asinl|acos|acosh|acoshf|acoshl|acosf|acosl|atoi|atof|atol|atoll|atexit|atan|atanh|atanhf|atanhl|atan2|atan2f|atan2l|atanf|atanl|abs|abort|gets|getc|getchar|getenv|getwc|getwchar|gmtime|rint|rintf|rintl|round|roundf|roundl|rename|realloc|rewind|remove|remquo|remquof|remquol|remainder|remainderf|remainderl|rand|raise|bsearch|btowc|modf|modff|modfl|memset|memchr|memcpy|memcmp|memmove|mktime|malloc|mbsinit|mbstowcs|mbsrtowcs|mbtowc|mblen|mbrtowc|mbrlen\";\n\nvar c_cppHighlightRules = function(extraKeywords) {\n\n    var keywordControls = (\n        \"break|case|continue|default|do|else|for|goto|if|_Pragma|\" +\n        \"return|switch|while|catch|operator|try|throw|using\"\n    );\n    \n    var storageType = (\n        \"asm|__asm__|auto|bool|_Bool|char|_Complex|double|enum|float|\" +\n        \"_Imaginary|int|int8_t|int16_t|int32_t|int64_t|long|short|signed|size_t|struct|typedef|uint8_t|uint16_t|uint32_t|uint64_t|union|unsigned|void|\" +\n        \"class|wchar_t|template|char16_t|char32_t\"\n    );\n\n    var storageModifiers = (\n        \"const|extern|register|restrict|static|volatile|inline|private|\" +\n        \"protected|public|friend|explicit|virtual|export|mutable|typename|\" +\n        \"constexpr|new|delete|alignas|alignof|decltype|noexcept|thread_local\"\n    );\n\n    var keywordOperators = (\n        \"and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|typeid|xor|xor_eq|\" +\n        \"const_cast|dynamic_cast|reinterpret_cast|static_cast|sizeof|namespace\"\n    );\n\n    var builtinConstants = (\n        \"NULL|true|false|TRUE|FALSE|nullptr\"\n    );\n\n    var keywordMapper = this.$keywords = this.createKeywordMapper(Object.assign({\n        \"keyword.control\" : keywordControls,\n        \"storage.type\" : storageType,\n        \"storage.modifier\" : storageModifiers,\n        \"keyword.operator\" : keywordOperators,\n        \"variable.language\": \"this\",\n        \"constant.language\": builtinConstants,\n        \"support.function.C99.c\": cFunctions\n    }, extraKeywords), \"identifier\");\n\n    var identifierRe = \"[a-zA-Z\\\\$_\\u00a1-\\uffff][a-zA-Z\\\\d\\\\$_\\u00a1-\\uffff]*\\\\b\";\n    var escapeRe = /\\\\(?:['\"?\\\\abfnrtv]|[0-7]{1,3}|x[a-fA-F\\d]{2}|u[a-fA-F\\d]{4}U[a-fA-F\\d]{8}|.)/.source;\n    var formatRe = \"%\"\n          + /(\\d+\\$)?/.source // field (argument #)\n          + /[#0\\- +']*/.source // flags\n          + /[,;:_]?/.source // separator character (AltiVec)\n          + /((-?\\d+)|\\*(-?\\d+\\$)?)?/.source // minimum field width\n          + /(\\.((-?\\d+)|\\*(-?\\d+\\$)?)?)?/.source // precision\n          + /(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?/.source // length modifier\n          + /(\\[[^\"\\]]+\\]|[diouxXDOUeEfFgGaACcSspn%])/.source; // conversion type\n          \n    // regexp must not have capturing parentheses. Use (?:) instead.\n    // regexps are ordered -> the first match is used\n\n    this.$rules = { \n        \"start\" : [\n            {\n                token : \"comment\",\n                regex : \"//$\",\n                next : \"start\"\n            }, {\n                token : \"comment\",\n                regex : \"//\",\n                next : \"singleLineComment\"\n            },\n            DocCommentHighlightRules.getStartRule(\"doc-start\"),\n            {\n                token : \"comment\", // multi line comment\n                regex : \"\\\\/\\\\*\",\n                next : \"comment\"\n            }, {\n                token : \"string\", // character\n                regex : \"'(?:\" + escapeRe + \"|.)?'\"\n            }, {\n                token : \"string.start\",\n                regex : '\"', \n                stateName: \"qqstring\",\n                next: [\n                    { token: \"string\", regex: /\\\\\\s*$/, next: \"qqstring\" },\n                    { token: \"constant.language.escape\", regex: escapeRe },\n                    { token: \"constant.language.escape\", regex: formatRe },\n                    { token: \"string.end\", regex: '\"|$', next: \"start\" },\n                    { defaultToken: \"string\"}\n                ]\n            }, {\n                token : \"string.start\",\n                regex : 'R\"\\\\(', \n                stateName: \"rawString\",\n                next: [\n                    { token: \"string.end\", regex: '\\\\)\"', next: \"start\" },\n                    { defaultToken: \"string\"}\n                ]\n            }, {\n                token : \"constant.numeric\", // hex\n                regex : \"0[xX][0-9a-fA-F]+(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\\\b\"\n            }, {\n                token : \"constant.numeric\", // float\n                regex : \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\\\b\"\n            }, {\n                token : \"keyword\", // pre-compiler directives\n                regex : \"#\\\\s*(?:include|import|pragma|line|define|undef)\\\\b\",\n                next  : \"directive\"\n            }, {\n                token : \"keyword\", // special case pre-compiler directive\n                regex : \"#\\\\s*(?:endif|if|ifdef|else|elif|ifndef)\\\\b\"\n            }, {\n                token : keywordMapper,\n                regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\"\n            }, {\n                token : \"keyword.operator\",\n                regex : /--|\\+\\+|<<=|>>=|>>>=|<>|&&|\\|\\||\\?:|[*%\\/+\\-&\\^|~!<>=]=?/\n            }, {\n              token : \"punctuation.operator\",\n              regex : \"\\\\?|\\\\:|\\\\,|\\\\;|\\\\.\"\n            }, {\n                token : \"paren.lparen\",\n                regex : \"[[({]\"\n            }, {\n                token : \"paren.rparen\",\n                regex : \"[\\\\])}]\"\n            }, {\n                token : \"text\",\n                regex : \"\\\\s+\"\n            }\n        ],\n        \"comment\" : [\n            {\n                token : \"comment\", // closing comment\n                regex : \"\\\\*\\\\/\",\n                next : \"start\"\n            }, {\n                defaultToken : \"comment\"\n            }\n        ],\n        \"singleLineComment\" : [\n            {\n                token : \"comment\",\n                regex : /\\\\$/,\n                next : \"singleLineComment\"\n            }, {\n                token : \"comment\",\n                regex : /$/,\n                next : \"start\"\n            }, {\n                defaultToken: \"comment\"\n            }\n        ],\n        \"directive\" : [\n            {\n                token : \"constant.other.multiline\",\n                regex : /\\\\/\n            },\n            {\n                token : \"constant.other.multiline\",\n                regex : /.*\\\\/\n            },\n            {\n                token : \"constant.other\",\n                regex : \"\\\\s*<.+?>\",\n                next : \"start\"\n            },\n            {\n                token : \"constant.other\", // single line\n                regex : '\\\\s*[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]',\n                next : \"start\"\n            }, \n            {\n                token : \"constant.other\", // single line\n                regex : \"\\\\s*['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\",\n                next : \"start\"\n            },\n            // \"\\\" implies multiline, while \"/\" implies comment\n            {\n                token : \"constant.other\",\n                regex : /[^\\\\\\/]+/,\n                next : \"start\"\n            }\n        ]\n    };\n\n    this.embedRules(DocCommentHighlightRules, \"doc-\",\n        [ DocCommentHighlightRules.getEndRule(\"start\") ]);\n    this.normalizeRules();\n};\n\noop.inherits(c_cppHighlightRules, TextHighlightRules);\n\nexports.c_cppHighlightRules = c_cppHighlightRules;\n","/*\n  THIS FILE WAS AUTOGENERATED BY mode.tmpl.js\n*/\n\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar CMode = require(\"./c_cpp\").Mode;\nvar DartHighlightRules = require(\"./dart_highlight_rules\").DartHighlightRules;\nvar CStyleFoldMode = require(\"./folding/cstyle\").FoldMode;\n\nvar Mode = function() {\n    CMode.call(this);\n    this.HighlightRules = DartHighlightRules;\n    this.foldingRules = new CStyleFoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, CMode);\n\n(function() { \n    this.lineCommentStart = \"//\";\n    this.blockComment = {start: \"/*\", end: \"*/\"};\n    this.$id = \"ace/mode/dart\";\n    this.snippetFileId = \"ace/snippets/dart\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","/*\n  THIS FILE WAS AUTOGENERATED BY mode_highlight_rules.tmpl.js (UUID: 958518BC-799F-477A-99F9-5B28EBF230F6) */\n\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar DocCommentHighlightRules = require(\"./doc_comment_highlight_rules\").DocCommentHighlightRules;\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar DartHighlightRules = function() {\n\n    var constantLanguage = \"true|false|null\";\n    var variableLanguage = \"this|super\";\n    var keywordControl = \"try|catch|finally|throw|rethrow|assert|break|case|continue|default|do|else|for|if|in|return|switch|while|new|deferred|async|await\";\n    var keywordDeclaration = \"abstract|class|extends|external|factory|implements|get|native|operator|set|typedef|with|enum\";\n    var storageModifier = \"static|final|const\";\n    var storageType = \"void|bool|num|int|double|dynamic|var|String\";\n\n    var keywordMapper = this.createKeywordMapper({\n        \"constant.language.dart\": constantLanguage,\n        \"variable.language.dart\": variableLanguage,\n        \"keyword.control.dart\": keywordControl,\n        \"keyword.declaration.dart\": keywordDeclaration,\n        \"storage.modifier.dart\": storageModifier,\n        \"storage.type.primitive.dart\": storageType\n    }, \"identifier\");\n\n    var stringfill = [{\n        token : \"constant.language.escape\",\n        regex : /\\\\./\n    }, {\n        token : \"text\",\n        regex : /\\$(?:\\w+|{[^\"'}]+})?/\n    }, {\n        defaultToken : \"string\"\n    }];\n\n    // regexp must not have capturing parentheses. Use (?:) instead.\n    // regexps are ordered -> the first match is used\n\n    this.$rules = {\n    \"start\": [\n        {\n            token : \"comment\",\n            regex : /\\/\\/.*$/\n        },\n        DocCommentHighlightRules.getStartRule(\"doc-start\"),\n        {\n            token : \"comment\", // multi line comment\n            regex : /\\/\\*/,\n            next : \"comment\"\n        },\n        {\n            token: [\"meta.preprocessor.script.dart\"],\n            regex: \"^(#!.*)$\"\n        },\n        {\n            token: \"keyword.other.import.dart\",\n            regex: \"(?:\\\\b)(?:library|import|export|part|of|show|hide)(?:\\\\b)\"\n        },\n        {\n            token : [\"keyword.other.import.dart\", \"text\"],\n            regex : \"(?:\\\\b)(prefix)(\\\\s*:)\"\n        },\n        {\n            regex: \"\\\\bas\\\\b\",\n            token: \"keyword.cast.dart\"\n        },\n        {\n            regex: \"\\\\?|:\",\n            token: \"keyword.control.ternary.dart\"\n        },\n        {\n            regex: \"(?:\\\\b)(is\\\\!?)(?:\\\\b)\",\n            token: [\"keyword.operator.dart\"]\n        },\n        {\n            regex: \"(<<|>>>?|~|\\\\^|\\\\||&)\",\n            token: [\"keyword.operator.bitwise.dart\"]\n        },\n        {\n            regex: \"((?:&|\\\\^|\\\\||<<|>>>?)=)\",\n            token: [\"keyword.operator.assignment.bitwise.dart\"]\n        },\n        {\n            regex: \"(===?|!==?|<=?|>=?)\",\n            token: [\"keyword.operator.comparison.dart\"]\n        },\n        {\n            regex: \"((?:[+*/%-]|\\\\~)=)\",\n            token: [\"keyword.operator.assignment.arithmetic.dart\"]\n        },\n        {\n            regex: \"=\",\n            token: \"keyword.operator.assignment.dart\"\n        },\n        {\n            token : \"string\",\n            regex : \"'''\",\n            next : \"qdoc\"\n        }, \n        {\n            token : \"string\",\n            regex : '\"\"\"',\n            next : \"qqdoc\"\n        }, \n        {\n            token : \"string\",\n            regex : \"'\",\n            next : \"qstring\"\n        }, \n        {\n            token : \"string\",\n            regex : '\"',\n            next : \"qqstring\"\n        }, \n        {\n            regex: \"(\\\\-\\\\-|\\\\+\\\\+)\",\n            token: [\"keyword.operator.increment-decrement.dart\"]\n        },\n        {\n            regex: \"(\\\\-|\\\\+|\\\\*|\\\\/|\\\\~\\\\/|%)\",\n            token: [\"keyword.operator.arithmetic.dart\"]\n        },\n        {\n            regex: \"(!|&&|\\\\|\\\\|)\",\n            token: [\"keyword.operator.logical.dart\"]\n        },\n        {\n            token : \"constant.numeric\", // hex\n            regex : \"0[xX][0-9a-fA-F]+\\\\b\"\n        }, \n        {\n            token : \"constant.numeric\", // float\n            regex : \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n        }, \n        {\n            token : keywordMapper,\n            regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n        }\n    ],\n    \"comment\" : [\n        {\n            token : \"comment\", // closing comment\n            regex : \"\\\\*\\\\/\",\n            next : \"start\"\n        }, {\n            defaultToken : \"comment\"\n        }\n    ],\n    \"qdoc\" : [\n        {\n            token : \"string\",\n            regex : \"'''\",\n            next : \"start\"\n        }\n    ].concat(stringfill),\n\n    \"qqdoc\" : [\n        {\n            token : \"string\",\n            regex : '\"\"\"',\n            next : \"start\"\n        }\n    ].concat(stringfill),\n\n    \"qstring\" : [\n        {\n            token : \"string\",\n            regex : \"'|$\",\n            next : \"start\"\n        }\n    ].concat(stringfill),\n\n    \"qqstring\" : [\n        {\n            token : \"string\",\n            regex : '\"|$',\n            next : \"start\"\n        }\n    ].concat(stringfill)\n    // TODO add support for interpolation and raw strings\n};\n\n    this.embedRules(DocCommentHighlightRules, \"doc-\",\n        [ DocCommentHighlightRules.getEndRule(\"start\") ]);\n};\n\noop.inherits(DartHighlightRules, TextHighlightRules);\n\nexports.DartHighlightRules = DartHighlightRules;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar DocCommentHighlightRules = function () {\n    this.$rules = {\n        \"start\": [\n            {\n                token: \"comment.doc.tag\",\n                regex: \"@\\\\w+(?=\\\\s|$)\"\n            }, DocCommentHighlightRules.getTagRule(), {\n                defaultToken: \"comment.doc.body\",\n                caseInsensitive: true\n            }\n        ]\n    };\n};\n\noop.inherits(DocCommentHighlightRules, TextHighlightRules);\n\nDocCommentHighlightRules.getTagRule = function(start) {\n    return {\n        token : \"comment.doc.tag.storage.type\",\n        regex : \"\\\\b(?:TODO|FIXME|XXX|HACK)\\\\b\"\n    };\n};\n\nDocCommentHighlightRules.getStartRule = function(start) {\n    return {\n        token : \"comment.doc\", // doc comment\n        regex: /\\/\\*\\*(?!\\/)/,\n        next  : start\n    };\n};\n\nDocCommentHighlightRules.getEndRule = function (start) {\n    return {\n        token : \"comment.doc\", // closing comment\n        regex : \"\\\\*\\\\/\",\n        next  : start\n    };\n};\n\n\nexports.DocCommentHighlightRules = DocCommentHighlightRules;\n","\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Range = require(\"../../range\").Range;\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\n\nvar FoldMode = exports.FoldMode = function(commentRegex) {\n    if (commentRegex) {\n        this.foldingStartMarker = new RegExp(\n            this.foldingStartMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.start)\n        );\n        this.foldingStopMarker = new RegExp(\n            this.foldingStopMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.end)\n        );\n    }\n};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    \n    this.foldingStartMarker = /([\\{\\[\\(])[^\\}\\]\\)]*$|^\\s*(\\/\\*)/;\n    this.foldingStopMarker = /^[^\\[\\{\\(]*([\\}\\]\\)])|^[\\s\\*]*(\\*\\/)/;\n    this.singleLineBlockCommentRe= /^\\s*(\\/\\*).*\\*\\/\\s*$/;\n    this.tripleStarBlockCommentRe = /^\\s*(\\/\\*\\*\\*).*\\*\\/\\s*$/;\n    this.startRegionRe = /^\\s*(\\/\\*|\\/\\/)#?region\\b/;\n    \n    //prevent naming conflict with any modes that inherit from cstyle and override this (like csharp)\n    this._getFoldWidgetBase = this.getFoldWidget;\n    \n    /**\n     * Gets fold widget with some non-standard extras:\n     *\n     * @example lineCommentRegionStart\n     *      //#region [optional description]\n     *\n     * @example blockCommentRegionStart\n     *      /*#region [optional description] *[/]\n     *\n     * @example tripleStarFoldingSection\n     *      /*** this folds even though 1 line because it has 3 stars ***[/]\n     * \n     * @note the pound symbol for region tags is optional\n     */\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n    \n        if (this.singleLineBlockCommentRe.test(line)) {\n            // No widget for single line block comment unless region or triple star\n            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))\n                return \"\";\n        }\n    \n        var fw = this._getFoldWidgetBase(session, foldStyle, row);\n    \n        if (!fw && this.startRegionRe.test(line))\n            return \"start\"; // lineCommentRegionStart\n    \n        return fw;\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {\n        var line = session.getLine(row);\n        \n        if (this.startRegionRe.test(line))\n            return this.getCommentRegionBlock(session, line, row);\n        \n        var match = line.match(this.foldingStartMarker);\n        if (match) {\n            var i = match.index;\n\n            if (match[1])\n                return this.openingBracketBlock(session, match[1], row, i);\n                \n            var range = session.getCommentFoldRange(row, i + match[0].length, 1);\n            \n            if (range && !range.isMultiLine()) {\n                if (forceMultiline) {\n                    range = this.getSectionRange(session, row);\n                } else if (foldStyle != \"all\")\n                    range = null;\n            }\n            \n            return range;\n        }\n\n        if (foldStyle === \"markbegin\")\n            return;\n\n        var match = line.match(this.foldingStopMarker);\n        if (match) {\n            var i = match.index + match[0].length;\n\n            if (match[1])\n                return this.closingBracketBlock(session, match[1], row, i);\n\n            return session.getCommentFoldRange(row, i, -1);\n        }\n    };\n    \n    this.getSectionRange = function(session, row) {\n        var line = session.getLine(row);\n        var startIndent = line.search(/\\S/);\n        var startRow = row;\n        var startColumn = line.length;\n        row = row + 1;\n        var endRow = row;\n        var maxRow = session.getLength();\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var indent = line.search(/\\S/);\n            if (indent === -1)\n                continue;\n            if  (startIndent > indent)\n                break;\n            var subRange = this.getFoldWidgetRange(session, \"all\", row);\n            \n            if (subRange) {\n                if (subRange.start.row <= startRow) {\n                    break;\n                } else if (subRange.isMultiLine()) {\n                    row = subRange.end.row;\n                } else if (startIndent == indent) {\n                    break;\n                }\n            }\n            endRow = row;\n        }\n        \n        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);\n    };\n    \n    /**\n     * gets comment region block with end region assumed to be start of comment in any cstyle mode or SQL mode (--) which inherits from this.\n     * There may optionally be a pound symbol before the region/endregion statement\n     */\n    this.getCommentRegionBlock = function(session, line, row) {\n        var startColumn = line.search(/\\s*$/);\n        var maxRow = session.getLength();\n        var startRow = row;\n        \n        var re = /^\\s*(?:\\/\\*|\\/\\/|--)#?(end)?region\\b/;\n        var depth = 1;\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var m = re.exec(line);\n            if (!m) continue;\n            if (m[1]) depth--;\n            else depth++;\n\n            if (!depth) break;\n        }\n\n        var endRow = row;\n        if (endRow > startRow) {\n            return new Range(startRow, startColumn, endRow, line.length);\n        }\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n"],"names":["oop","require","TextMode","c_cppHighlightRules","MatchingBraceOutdent","CStyleFoldMode","Mode","this","HighlightRules","$outdent","$behaviour","$defaultBehaviour","foldingRules","inherits","lineCommentStart","blockComment","start","end","getNextLineIndent","state","line","tab","indent","$getIndent","tokenizedLine","getTokenizer","getLineTokens","tokens","endState","length","type","match","checkOutdent","input","autoOutdent","doc","row","$id","snippetFileId","call","prototype","exports","DocCommentHighlightRules","TextHighlightRules","cFunctions","extraKeywords","keywordControls","storageType","storageModifiers","keywordOperators","builtinConstants","keywordMapper","$keywords","createKeywordMapper","Object","assign","escapeRe","source","formatRe","$rules","token","regex","next","getStartRule","stateName","defaultToken","embedRules","getEndRule","normalizeRules","CMode","DartHighlightRules","constantLanguage","variableLanguage","keywordControl","keywordDeclaration","storageModifier","stringfill","concat","getTagRule","caseInsensitive","Range","BaseFoldMode","FoldMode","commentRegex","foldingStartMarker","RegExp","replace","foldingStopMarker","singleLineBlockCommentRe","tripleStarBlockCommentRe","startRegionRe","_getFoldWidgetBase","getFoldWidget","session","foldStyle","getLine","test","fw","getFoldWidgetRange","forceMultiline","getCommentRegionBlock","i","index","openingBracketBlock","range","getCommentFoldRange","isMultiLine","getSectionRange","closingBracketBlock","startIndent","search","startRow","startColumn","endRow","maxRow","getLength","subRange","re","depth","m","exec","column","openBracePos","findMatchingBracket"],"sourceRoot":""}