{"version":3,"file":"js/300.dd0f7d3c.js","mappings":"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","sources":["webpack://admin/./node_modules/ace-code/src/ext/hardwrap.js","webpack://admin/./node_modules/ace-code/src/keyboard/vim.js"],"sourcesContent":["\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\n/**\n * @param {import(\"../editor\").Editor} editor\n * @param {import(\"../../ace-internal\").Ace.HardWrapOptions} options\n */\nfunction hardWrap(editor, options) {\n    var max = options.column || editor.getOption(\"printMarginColumn\");\n    var allowMerge = options.allowMerge != false;\n       \n    var row = Math.min(options.startRow, options.endRow);\n    var endRow = Math.max(options.startRow, options.endRow);\n    \n    var session = editor.session;\n    \n    while (row <= endRow) {\n        var line = session.getLine(row);\n        if (line.length > max) {\n            var space = findSpace(line, max, 5);\n            if (space) {\n                var indentation = /^\\s*/.exec(line)[0];\n                session.replace(new Range(row,space.start,row,space.end), \"\\n\" + indentation);\n            }\n            endRow++;\n        } else if (allowMerge && /\\S/.test(line) && row != endRow) {\n            var nextLine = session.getLine(row + 1);\n            if (nextLine && /\\S/.test(nextLine)) {\n                var trimmedLine = line.replace(/\\s+$/, \"\");\n                var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n                var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n\n                var space = findSpace(mergedLine, max, 5);\n                if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n                    var replaceRange = new Range(row,trimmedLine.length,row + 1,nextLine.length - trimmedNextLine.length);\n                    session.replace(replaceRange, \" \");\n                    row--;\n                    endRow--;\n                } else if (trimmedLine.length < line.length) {\n                    session.remove(new Range(row, trimmedLine.length, row, line.length));\n                }\n            }\n        }\n        row++;\n    }\n\n    /**\n     * @param {string} line\n     * @param {number} max\n     * @param {number} min\n     */\n    function findSpace(line, max, min) {\n        if (line.length < max)\n            return;\n        var before = line.slice(0, max);\n        var after = line.slice(max);\n        var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n        var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n        var start = 0;\n        var end = 0;\n        if (spaceBefore && !spaceBefore[2]) {\n            start = max - spaceBefore[1].length;\n            end = max;\n        }\n        if (spaceAfter && !spaceAfter[2]) {\n            if (!start)\n                start = max;\n            end = max + spaceAfter[1].length;\n        }\n        if (start) {\n            return {\n                start: start,\n                end: end\n            };\n        }\n        if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n            return {\n                start: spaceBefore.index,\n                end: spaceBefore.index + spaceBefore[2].length\n            };\n        }\n        if (spaceAfter && spaceAfter[2]) {\n            start =  max + spaceAfter[2].length;\n            return {\n                start: start,\n                end: start + spaceAfter[3].length\n            };\n        }\n    }\n\n}\n\nfunction wrapAfterInput(e) {\n    if (e.command.name == \"insertstring\" && /\\S/.test(e.args)) {\n        var editor = e.editor;\n        var cursor = editor.selection.cursor;\n        if (cursor.column <= editor.renderer.$printMarginColumn) return;\n        var lastDelta = editor.session.$undoManager.$lastDelta;\n\n        hardWrap(editor, {\n            startRow: cursor.row, endRow: cursor.row,\n            allowMerge: false\n        });\n        if (lastDelta != editor.session.$undoManager.$lastDelta) \n            editor.session.markUndoGroup();\n    }\n}\n\nvar Editor = require(\"../editor\").Editor;\nrequire(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    hardWrap: {\n        set: function(val) {\n            if (val) {\n                this.commands.on(\"afterExec\", wrapAfterInput);\n            } else {\n                this.commands.off(\"afterExec\", wrapAfterInput);\n            }\n        },\n        value: false\n    }\n});\n\nexports.hardWrap = hardWrap;\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n  'use strict';\n\n  function log() {\n    var d = \"\";\n    function format(p) {\n      if (typeof p != \"object\")\n        return p + \"\";\n      if (\"line\" in p) {\n        return p.line + \":\" + p.ch;\n      }\n      if (\"anchor\" in p) {\n        return format(p.anchor) + \"->\" + format(p.head);\n      }\n      if (Array.isArray(p))\n        return \"[\" + p.map(function(x) {\n          return format(x);\n        }) + \"]\";\n      return JSON.stringify(p);\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      var p = arguments[i];\n      var f = format(p);\n      d += f + \"  \";\n    }\n    console.log(d);\n  }\n  var Range = require(\"../range\").Range;\n  var EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n  var domLib = require(\"../lib/dom\");\n  var oop = require(\"../lib/oop\");\n  var KEYS = require(\"../lib/keys\");\n  var event = require(\"../lib/event\");\n  var Search = require(\"../search\").Search;\n  var useragent = require(\"../lib/useragent\");\n  var SearchHighlight = require(\"../search_highlight\").SearchHighlight;\n  var multiSelectCommands = require(\"../commands/multi_select_commands\");\n  var TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\n  var hardWrap = require(\"../ext/hardwrap\").hardWrap;\n  require(\"../multi_select\");\n\n  var CodeMirror = function(ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.options = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n  };\n  CodeMirror.Pos = function(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  };\n  CodeMirror.defineOption = function(name, val, setter) {};\n  CodeMirror.commands = {\n    redo: function(cm) { cm.ace.redo(); },\n    undo: function(cm) { cm.ace.undo(); },\n    newlineAndIndent: function(cm) { cm.ace.insert(\"\\n\"); },\n    goLineLeft: function(cm) { cm.ace.selection.moveCursorLineStart(); },\n    goLineRight: function(cm) { cm.ace.selection.moveCursorLineEnd(); }\n  };\n  CodeMirror.keyMap = {};\n  CodeMirror.addClass = CodeMirror.rmClass = function() {};\n  CodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\n  CodeMirror.keyName = function(e) {\n    var key = (KEYS[e.keyCode] || e.key || \"\");\n    if (key.length == 1) key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function(m) {\n      return m.toUpperCase();\n    }) + key;\n    return key;\n  };\n  CodeMirror.keyMap['default'] = function(key) {\n    return function(cm) {\n      var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n      return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n  };\n  CodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map) map = \"default\";\n    if (typeof map == \"string\")\n      map = CodeMirror.keyMap[map] ||  CodeMirror.keyMap['default'];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n\n    if (map.fallthrough) {\n      if (!Array.isArray(map.fallthrough))\n        return lookupKey(key, map.fallthrough, handle);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle);\n        if (result) return result;\n      }\n    }\n  };\n\n\n  CodeMirror.findMatchingTag = function (cm, head) {\n    return cm.findMatchingTag(head);\n  }\n\n  CodeMirror.findEnclosingTag = function (cm, head) {\n\n  };\n\n  CodeMirror.signal = function(o, name, e) { return o._signal(name, e) };\n  CodeMirror.on = event.addListener;\n  CodeMirror.off = event.removeListener;\n  CodeMirror.isWordChar = function(ch) {\n    if (ch < \"\\x7f\") return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n  };\n\n(function() {\n  oop.implement(CodeMirror.prototype, EventEmitter);\n\n  this.destroy = function() {\n    this.ace.off('change', this.onChange);\n    this.ace.off('changeSelection', this.onSelectionChange);\n    this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n    this.removeOverlay();\n  };\n  this.virtualSelectionMode = function() {\n    return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n  };\n  this.onChange = function(delta) {\n    if (this.$lineHandleChanges) {\n      this.$lineHandleChanges.push(delta);\n    }\n    var change = { text: delta.action[0] == 'i' ? delta.lines : [] };\n    var curOp = this.curOp = this.curOp || {};\n    if (!curOp.changeHandlers)\n      curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n    if (!curOp.lastChange) {\n      curOp.lastChange = curOp.change = change;\n    } else {\n      curOp.lastChange.next = curOp.lastChange = change;\n    }\n    this.$updateMarkers(delta);\n  };\n  this.onSelectionChange = function() {\n    var curOp = this.curOp = this.curOp || {};\n    if (!curOp.cursorActivityHandlers)\n      curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n    this.curOp.cursorActivity = true;\n    if (this.ace.inMultiSelectMode) {\n      this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n    }\n  };\n  this.operation = function(fn, force) {\n    if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n      return fn();\n    }\n    if (force || !this.ace.curOp) {\n      if (this.curOp)\n        this.onBeforeEndOperation();\n    }\n    if (!this.ace.curOp) {\n      var prevOp = this.ace.prevOp;\n      this.ace.startOperation({\n        command: { name: \"vim\",  scrollIntoView: \"cursor\" }\n      });\n    }\n    var curOp = this.curOp = this.curOp || {};\n    this.curOp.force = force;\n    var result = fn();\n    if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n      if (this.state.dialog)\n        this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;\n      this.ace.endOperation();\n      if (!curOp.cursorActivity && !curOp.lastChange && prevOp)\n        this.ace.prevOp = prevOp;\n    }\n    if (force || !this.ace.curOp) {\n      if (this.curOp)\n        this.onBeforeEndOperation();\n    }\n    return result;\n  };\n  this.onBeforeEndOperation = function() {\n    var op = this.curOp;\n    if (op) {\n      if (op.change) { this.signal(\"change\", op.change, op); }\n      if (op && op.cursorActivity) { this.signal(\"cursorActivity\", null, op); }\n      this.curOp = null;\n    }\n  };\n\n  this.signal = function(eventName, e, handlers) {\n    var listeners = handlers ? handlers[eventName + \"Handlers\"]\n        : (this._eventRegistry || {})[eventName];\n    if (!listeners)\n        return;\n    listeners = listeners.slice();\n    for (var i=0; i<listeners.length; i++)\n        listeners[i](this, e);\n  };\n  this.firstLine = function() { return 0; };\n  this.lastLine = function() { return this.ace.session.getLength() - 1; };\n  this.lineCount = function() { return this.ace.session.getLength(); };\n  this.setCursor = function(line, ch) {\n    if (typeof line === 'object') {\n      ch = line.ch;\n      line = line.line;\n    }\n    var shouldScroll = !this.curOp && !this.ace.inVirtualSelectionMode;\n    if (!this.ace.inVirtualSelectionMode)\n      this.ace.exitMultiSelectMode();\n    this.ace.session.unfold({row: line, column: ch});\n    this.ace.selection.moveTo(line, ch);\n    if (shouldScroll) {\n      this.ace.renderer.scrollCursorIntoView();\n      this.ace.endOperation();\n    }\n  };\n  this.getCursor = function(p) {\n    var sel = this.ace.selection;\n    var pos = p == 'anchor' ? (sel.isEmpty() ? sel.lead : sel.anchor) :\n        p == 'head' || !p ? sel.lead : sel.getRange()[p];\n    return toCmPos(pos);\n  };\n  this.listSelections = function(p) {\n    var ranges = this.ace.multiSelect.rangeList.ranges;\n    if (!ranges.length || this.ace.inVirtualSelectionMode)\n      return [{anchor: this.getCursor('anchor'), head: this.getCursor('head')}];\n    return ranges.map(function(r) {\n      return {\n        anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n        head: this.clipPos(toCmPos(r.cursor))\n      };\n    }, this);\n  };\n  this.setSelections = function(p, primIndex) {\n    var sel = this.ace.multiSelect;\n    var ranges = p.map(function(x) {\n      var anchor = toAcePos(x.anchor);\n      var head = toAcePos(x.head);\n      var r = Range.comparePoints(anchor, head) < 0\n        ? new Range.fromPoints(anchor, head)\n        : new Range.fromPoints(head, anchor);\n      r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n      return r;\n    });\n\n    if (this.ace.inVirtualSelectionMode) {\n      this.ace.selection.fromOrientedRange(ranges[0]);\n      return;\n    }\n    if (!primIndex) {\n        ranges = ranges.reverse();\n    } else if (ranges[primIndex]) {\n       ranges.push(ranges.splice(primIndex, 1)[0]);\n    }\n    sel.toSingleRange(ranges[0].clone());\n    var session = this.ace.session;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n      sel.addRange(range);\n    }\n  };\n  this.setSelection = function(a, h, options) {\n    var sel = this.ace.selection;\n    sel.moveTo(a.line, a.ch);\n    sel.selectTo(h.line, h.ch);\n    if (options && options.origin == '*mouse') {\n      this.onBeforeEndOperation();\n    }\n  };\n  this.somethingSelected = function(p) {\n    return !this.ace.selection.isEmpty();\n  };\n  this.clipPos = function(p) {\n    var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n    return toCmPos(pos);\n  };\n  this.foldCode = function(pos) {\n    this.ace.session.$toggleFoldWidget(pos.line, {});\n  };\n  this.markText = function(cursor) {\n    // only used for fat-cursor, not needed\n    return {clear: function() {}, find: function() {}};\n  };\n  this.$updateMarkers = function(delta) {\n    var isInsert = delta.action == \"insert\";\n    var start = delta.start;\n    var end = delta.end;\n    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n    if (isInsert) end = start;\n\n    for (var i in this.marks) {\n      var point = this.marks[i];\n      var cmp = Range.comparePoints(point, start);\n      if (cmp < 0) {\n        continue; // delta starts after the range\n      }\n      if (cmp === 0) {\n        if (isInsert) {\n          if (!point.$insertRight) {\n            cmp = 1;\n          }\n          else if (point.bias == 1) {\n            cmp = 1;\n          } else {\n            point.bias = -1;\n            continue;\n          }\n        }\n      }\n      var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n      if (cmp2 > 0) {\n        point.row += rowShift;\n        point.column += point.row == end.row ? colShift : 0;\n        continue;\n      }\n      if (!isInsert && cmp2 <= 0) {\n        point.row = start.row;\n        point.column = start.column;\n        if (cmp2 === 0)\n          point.bias = 1;\n      }\n    }\n  };\n  var Marker = function(cm, id, row, column) {\n    this.cm = cm;\n    this.id = id;\n    this.row = row;\n    this.column = column;\n    cm.marks[this.id] = this;\n  };\n  Marker.prototype.clear = function() { delete this.cm.marks[this.id] };\n  Marker.prototype.find = function() { return toCmPos(this) };\n  this.setBookmark = function(cursor, options) {\n    var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n    if (!options || !options.insertLeft)\n      bm.$insertRight = true;\n    this.marks[bm.id] = bm;\n    return bm;\n  };\n  this.moveH = function(increment, unit) {\n    if (unit == 'char') {\n      var sel = this.ace.selection;\n      sel.clearSelection();\n      sel.moveCursorBy(0, increment);\n    }\n  };\n  this.findPosV = function(start, amount, unit, goalColumn) {\n    if (unit == 'page') {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      amount = amount * Math.floor(config.height / config.lineHeight);\n      unit = 'line';\n    }\n    if (unit == 'line') {\n      var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n      if (goalColumn != null)\n        screenPos.column = goalColumn;\n      screenPos.row += amount;\n      // not what codemirror does but vim mode needs only this\n      screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n      var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n      return toCmPos(pos);\n    } else {\n      debugger;\n    }\n  };\n  this.charCoords = function(pos, mode) {\n    if (mode == 'div' || !mode) {\n      var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n      return {left: sc.column, top: sc.row};\n    }if (mode == 'local') {\n      var renderer = this.ace.renderer;\n      var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n      var lh = renderer.layerConfig.lineHeight;\n      var cw = renderer.layerConfig.characterWidth;\n      var top = lh * sc.row;\n      return {left: sc.column * cw, top: top, bottom: top + lh};\n    }\n  };\n  this.coordsChar = function(pos, mode) {\n    var renderer = this.ace.renderer;\n    if (mode == 'local') {\n      var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n      var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n      var ch = renderer.session.screenToDocumentPosition(row, col);\n      return toCmPos(ch);\n    } else if (mode == 'div') {\n      throw \"not implemented\";\n    }\n  };\n  this.getSearchCursor = function(query, pos, caseFold) {\n    var caseSensitive = false;\n    var isRegexp = false;\n    if (query instanceof RegExp && !query.global) {\n      caseSensitive = !query.ignoreCase;\n      query = query.source;\n      isRegexp = true;\n    }\n    if (query == \"\\\\n\") { query = \"\\n\"; isRegexp = false; }\n    var search = new Search();\n    if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\n    var acePos = {row: pos.line, column: pos.ch};\n    var cm = this;\n    var last = null;\n    return {\n      findNext: function() { return this.find(false) },\n      findPrevious: function() {return this.find(true) },\n      find: function(back) {\n        search.setOptions({\n          needle: query,\n          caseSensitive: caseSensitive,\n          wrap: false,\n          backwards: back,\n          regExp: isRegexp,\n          start: last || acePos\n        });\n        var range = search.find(cm.ace.session);\n        last = range;\n        return last && [!last.isEmpty()];\n      },\n      from: function() { return last && toCmPos(last.start) },\n      to: function() { return last && toCmPos(last.end) },\n      replace: function(text) {\n        if (last) {\n          last.end = cm.ace.session.doc.replace(last, text);\n        }\n      }\n    };\n  };\n  this.scrollTo = function(x, y) {\n    var renderer = this.ace.renderer;\n    var config = renderer.layerConfig;\n    var maxHeight = config.maxHeight;\n    maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n    if (y != null) this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n    if (x != null) this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n  };\n  this.scrollInfo = function() { return 0; };\n  this.scrollIntoView = function(pos, margin) {\n    if (pos) {\n      var renderer = this.ace.renderer;\n      var viewMargin = { \"top\": 0, \"bottom\": margin };\n      renderer.scrollCursorIntoView(toAcePos(pos),\n        (renderer.lineHeight * 2) / renderer.$size.scrollerHeight, viewMargin);\n    }\n  };\n  this.getLine = function(row) { return this.ace.session.getLine(row) };\n  this.getRange = function(s, e) {\n    return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n  };\n  this.replaceRange = function(text, s, e) {\n    if (!e) e = s;\n    // workaround for session.replace not handling negative rows\n    var range = new Range(s.line, s.ch, e.line, e.ch);\n    this.ace.session.$clipRangeToDocument(range);\n    return this.ace.session.replace(range, text);\n  };\n  this.replaceSelection =\n  this.replaceSelections = function(p) {\n    var strings = Array.isArray(p) && p;\n    var sel = this.ace.selection;\n    if (this.ace.inVirtualSelectionMode) {\n      this.ace.session.replace(sel.getRange(), strings ? p[0] || \"\": p );\n      return;\n    }\n    sel.inVirtualSelectionMode = true;\n    var ranges = sel.rangeList.ranges;\n    if (!ranges.length) ranges = [this.ace.multiSelect.getRange()];\n    for (var i = ranges.length; i--;)\n       this.ace.session.replace(ranges[i], strings ? p[i] || \"\" : p);\n    sel.inVirtualSelectionMode = false;\n  };\n  this.getSelection = function() {\n    return this.ace.getSelectedText();\n  };\n  this.getSelections = function() {\n    return this.listSelections().map(function(x) {\n      return this.getRange(x.anchor, x.head);\n    }, this);\n  };\n  this.getInputField = function() {\n    return this.ace.textInput.getElement();\n  };\n  this.getWrapperElement = function() {\n    return this.ace.container;\n  };\n  var optMap = {\n    indentWithTabs: \"useSoftTabs\",\n    indentUnit: \"tabSize\",\n    tabSize: \"tabSize\",\n    firstLineNumber: \"firstLineNumber\",\n    readOnly: \"readOnly\"\n  };\n  this.setOption = function(name, val) {\n    this.state[name] = val;\n    switch (name) {\n      case 'indentWithTabs':\n        name = optMap[name];\n        val = !val;\n      break;\n      case 'keyMap':\n        this.state.$keyMap = val;\n        return;\n      break;\n      default:\n        name = optMap[name];\n    }\n    if (name)\n      this.ace.setOption(name, val);\n  };\n  this.getOption = function(name) {\n    var val;\n    var aceOpt = optMap[name];\n    if (aceOpt)\n      val = this.ace.getOption(aceOpt);\n    switch (name) {\n      case 'indentWithTabs':\n        name = optMap[name];\n        return !val;\n      case 'keyMap':\n        return this.state.$keyMap || 'vim';\n    }\n    return aceOpt ? val : this.state[name];\n  };\n  this.toggleOverwrite = function(on) {\n    this.state.overwrite = on;\n    return this.ace.setOverwrite(on);\n  };\n  this.addOverlay = function(o) {\n    if (!this.$searchHighlight || !this.$searchHighlight.session) {\n      var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n      var marker = this.ace.session.addDynamicMarker(highlight);\n      highlight.id = marker.id;\n      highlight.session = this.ace.session;\n      highlight.destroy = function(o) {\n        highlight.session.off(\"change\", highlight.updateOnChange);\n        highlight.session.off(\"changeEditor\", highlight.destroy);\n        highlight.session.removeMarker(highlight.id);\n        highlight.session = null;\n      };\n      highlight.updateOnChange = function(delta) {\n        var row = delta.start.row;\n        if (row == delta.end.row) highlight.cache[row] = undefined;\n        else highlight.cache.splice(row, highlight.cache.length);\n      };\n      highlight.session.on(\"changeEditor\", highlight.destroy);\n      highlight.session.on(\"change\", highlight.updateOnChange);\n    }\n    var re = new RegExp(o.query.source, \"gmi\");\n    this.$searchHighlight = o.highlight = highlight;\n    this.$searchHighlight.setRegexp(re);\n    this.ace.renderer.updateBackMarkers();\n  };\n  this.removeOverlay = function(o) {\n    if (this.$searchHighlight && this.$searchHighlight.session) {\n      this.$searchHighlight.destroy();\n    }\n  };\n  this.getScrollInfo = function() {\n    var renderer = this.ace.renderer;\n    var config = renderer.layerConfig;\n    return {\n      left: renderer.scrollLeft,\n      top: renderer.scrollTop,\n      height: config.maxHeight,\n      width: config.width,\n      clientHeight: config.height,\n      clientWidth: config.width\n    };\n  };\n  this.getValue = function() {\n    return this.ace.getValue();\n  };\n  this.setValue = function(v) {\n    return this.ace.setValue(v, -1);\n  };\n  this.getTokenTypeAt = function(pos) {\n    var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n    return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n  };\n  this.findMatchingBracket = function(pos) {\n    var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n    return {to: m && toCmPos(m)};\n  };\n  this.findMatchingTag = function (pos) {\n    var m = this.ace.session.getMatchingTags(toAcePos(pos));\n    if (!m) return;\n    return {\n      open: {\n        from: toCmPos(m.openTag.start),\n        to: toCmPos(m.openTag.end)\n      },\n      close: {\n        from: toCmPos(m.closeTag.start),\n        to: toCmPos(m.closeTag.end)\n      }\n    };\n  };\n  this.indentLine = function(line, method) {\n    if (method === true)\n        this.ace.session.indentRows(line, line, \"\\t\");\n    else if (method === false)\n        this.ace.session.outdentRows(new Range(line, 0, line, 0));\n  };\n  this.indexFromPos = function(pos) {\n    return this.ace.session.doc.positionToIndex(toAcePos(pos));\n  };\n  this.posFromIndex = function(index) {\n    return toCmPos(this.ace.session.doc.indexToPosition(index));\n  };\n  this.focus = function(index) {\n    return this.ace.textInput.focus();\n  };\n  this.blur = function(index) {\n    return this.ace.blur();\n  };\n  this.defaultTextHeight = function(index) {\n    return this.ace.renderer.layerConfig.lineHeight;\n  };\n  this.scanForBracket = function(pos, dir, _, options) {\n    var re = options.bracketRegex.source;\n    var tokenRe = /paren|text|operator|tag/;\n    if (dir == 1) {\n      var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n    } else {\n      var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), {row: pos.line, column: pos.ch + 1}, tokenRe);\n      if (!m && options.bracketRegex && options.bracketRegex.test(this.getLine(pos.line)[pos.ch - 1])) {\n          m = {row: pos.line, column: pos.ch - 1};\n      }\n    }\n    return m && {pos: toCmPos(m)};\n  };\n  this.refresh = function() {\n    return this.ace.resize(true);\n  };\n  this.getMode = function() {\n    return { name : this.getOption(\"mode\") };\n  };\n  this.execCommand = function(name) {\n    if (CodeMirror.commands.hasOwnProperty(name)) return CodeMirror.commands[name](this);\n    if (name == \"indentAuto\") return this.ace.execCommand(\"autoindent\");\n    console.log(name + \" is not implemented\");\n  };\n  this.getLineNumber = function(handle) {\n    var deltas = this.$lineHandleChanges;\n    if (!deltas)\n        return null;\n    var row = handle.row;\n    for (var i = 0; i < deltas.length; i++) {\n        var delta = deltas[i];\n        if (delta.start.row != delta.end.row) {\n            if (delta.action[0] == \"i\") {\n                if (delta.start.row < row)\n                    row += delta.end.row - delta.start.row;\n            }  else {\n                if (delta.start.row < row) {\n                    if (row < delta.end.row || row == delta.end.row && delta.start.column > 0) {\n                        return null;\n                    }\n                    row -= delta.end.row - delta.start.row;\n                }\n            }\n        }\n    }\n    return row;\n  };\n  this.getLineHandle = function(row) {\n    if (!this.$lineHandleChanges)\n      this.$lineHandleChanges = [];\n    return {text: this.ace.session.getLine(row), row: row};\n  };\n  this.releaseLineHandles = function() {\n    this.$lineHandleChanges = undefined;\n  };\n  this.getLastEditEnd = function() {\n    var undoManager = this.ace.session.$undoManager;\n    if (undoManager && undoManager.$lastDelta)\n      return toCmPos(undoManager.$lastDelta.end);\n  };\n}).call(CodeMirror.prototype);\n  function toAcePos(cmPos) {\n    return {row: cmPos.line, column: cmPos.ch};\n  }\n  function toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n  }\n\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      throw \"not implemented\";\n    },\n    indentation: function() {\n      throw \"not implemented\";\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n\n// todo replace with showCommandLine\nCodeMirror.defineExtension = function(name, fn) {\n  CodeMirror.prototype[name] = fn;\n};\ndomLib.importCssString(`.normal-mode .ace_cursor{\n    border: none;\n    background-color: rgba(255,0,0,0.5);\n}\n.normal-mode .ace_hidden-cursors .ace_cursor{\n  background-color: transparent;\n  border: 1px solid red;\n  opacity: 0.7\n}\n.ace_dialog {\n  position: absolute;\n  left: 0; right: 0;\n  background: inherit;\n  z-index: 15;\n  padding: .1em .8em;\n  overflow: hidden;\n  color: inherit;\n}\n.ace_dialog-top {\n  border-bottom: 1px solid #444;\n  top: 0;\n}\n.ace_dialog-bottom {\n  border-top: 1px solid #444;\n  bottom: 0;\n}\n.ace_dialog input {\n  border: none;\n  outline: none;\n  background: transparent;\n  width: 20em;\n  color: inherit;\n  font-family: monospace;\n}`, \"vimMode\", false);\n(function() {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.ace.container;\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"ace_dialog ace_dialog-bottom\";\n    else\n      dialog.className = \"ace_dialog ace_dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (this.virtualSelectionMode()) return;\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    this.state.dialog = dialog;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n\n        if (newVal && newVal.type == \"blur\") {\n          if (document.activeElement === inp)\n            return;\n        }\n\n        if (me.state.dialog == dialog) {\n          me.state.dialog = null;\n          me.focus();\n        }\n        closed = true;\n        dialog.remove();\n\n        if (options.onClose) options.onClose(dialog);\n\n        // ace_patch{\n        var cm = me;\n        if (cm.state.vim) {\n          cm.state.vim.status = null;\n          cm.ace._signal(\"changeStatus\");\n          cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n        }\n        // ace_patch}\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) inp.select();\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 13) callback(inp.value);\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          CodeMirror.e_stop(e);\n          close();\n        }\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n\n      inp.focus();\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    if (this.virtualSelectionMode()) return;\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      dialog.remove();\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n})();\n\n\n  var Pos = CodeMirror.Pos;\n\n  function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    // start and character position when no selection \n    // is the same in visual mode, and differs in 1 character in normal mode\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n      var text = cm.getLine(curStart.line);\n      var charCode = text.charCodeAt(curStart.ch);\n      if (0xD800 <= charCode && charCode <= 0xD8FF) {\n        curEnd.ch += 1;\n      }\n    }\n\n    return {start: curStart, end: curEnd};\n  }\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x' },\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    {keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\"},\n    {keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    {keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<register>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<register>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    { keys: 'gq', type: 'operator', operator: 'hardWrap' },\n    { keys: 'gw', type: 'operator', operator: 'hardWrap', operatorArgs: {keepCursor: true}},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<register>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<register>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<register>', type: 'action', action: 'setMark' },\n    { keys: '\"<register>', type: 'action', action: 'setRegister' },\n    { keys: '<C-r><register>', type: 'action', action: 'insertRegister', context: 'insert', isEdit: true },\n    { keys: '<C-o>', type: 'action', action: 'oneNormalCommand', context: 'insert' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<register>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<register>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'omap', shortName: 'om' },\n    { name: 'noremap', shortName: 'no' },\n    { name: 'nnoremap', shortName: 'nn' },\n    { name: 'vnoremap', shortName: 'vn' },\n    { name: 'inoremap', shortName: 'ino' },\n    { name: 'onoremap', shortName: 'ono' },\n    { name: 'unmap' },\n    { name: 'mapclear', shortName: 'mapc' },\n    { name: 'nmapclear', shortName: 'nmapc' },\n    { name: 'vmapclear', shortName: 'vmapc' },\n    { name: 'imapclear', shortName: 'imapc' },\n    { name: 'omapclear', shortName: 'omapc' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'startinsert', shortName: 'start' },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'delete', shortName: 'd' },\n    { name: 'join', shortName: 'j' },\n    { name: 'normal', shortName: 'norm' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  /**\n   * Langmap\n   * Determines how to interpret keystrokes in Normal and Visual mode.\n   * Useful for people who use a different keyboard layout than QWERTY\n   */\n  var langmap = parseLangmap('');\n\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n      if (highlightTimeout) clearTimeout(highlightTimeout);\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    var validMarks = ['<', '>'];\n    var validRegisters = ['-', '\"', '.', ':', '_', '/', '+'];\n    var latinCharRegex = /^\\w$/\n    var upperCaseChars;\n    try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n    catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n    defineOption('textwidth', 80, 'number', ['tw'], function(width, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (width === undefined) {\n        var value = cm.getOption('textwidth');\n        return value;\n      } else {\n        var column = Math.round(width);\n        if (column > 1) {\n          cm.setOption('textwidth', column);\n        }\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n            this.onRecordingDone = cm.openDialog(template, null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          insertModeReturn: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {},\n          // Whether the next character should be interpreted literally\n          // Necassary for correct implementation of f<character>, r<character> etc.\n          // in terms of langmaps.\n          expectLiteralNext: false\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      enterVimMode: enterVimMode,\n      leaveVimMode: leaveVimMode,\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        exCommandDispatcher.map(lhs, rhs, ctx, true);\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      langmap: updateLangmap,\n      vimKeyFromEvent: vimKeyFromEvent,\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      multiSelectHandleKey: multiSelectHandleKey,\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            if (vim.visualMode) {\n              // Get back to normal mode.\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              // Get back to normal mode.\n              exitInsertMode(cm);\n            } else {\n              // We're already in normal mode. Let '<Esc>' be handled normally.\n              return;\n            }\n            clearInputState(cm);\n            return true;\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          vim.inputState.keyBuffer.push(key);\n          var keys = vim.inputState.keyBuffer.join(\"\");\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          var changeQueue = vim.inputState.changeQueue;\n\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (match.expectLiteralNext) vim.expectLiteralNext = true;\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = keysAreChars && window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer.length) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            if (keysAreChars) {\n              var selections = cm.listSelections();\n              if (!changeQueue || changeQueue.removed.length != selections.length)\n                changeQueue = vim.inputState.changeQueue = new ChangeQueue;\n              changeQueue.inserted += key;\n              for (var i = 0; i < selections.length; i++) {\n                var from = cursorMin(selections[i].anchor, selections[i].head);\n                var to = cursorMax(selections[i].anchor, selections[i].head);\n                var text = cm.getRange(from, cm.state.overwrite ? offsetCursor(to, 0, 1) : to);\n                changeQueue.removed[i] = (changeQueue.removed[i] || \"\") + text;\n              }\n            }\n            return !keysAreChars;\n          }\n          vim.expectLiteralNext = false;\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (match.command && changeQueue) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange(changeQueue.removed[i] || \"\", \n                offsetCursor(here, 0, -changeQueue.inserted.length), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          if (!match.command) clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          vim.inputState.keyBuffer.push(key);\n          var keys = vim.inputState.keyBuffer.join(\"\");\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (match.expectLiteralNext) vim.expectLiteralNext = true;\n            return true;\n          }\n          else if (match.type == 'clear') { clearInputState(cm); return true; }\n          vim.expectLiteralNext = false;\n\n          vim.inputState.keyBuffer.length = 0;\n          keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            if ((command.operator || command.isEdit) && cm.getOption('readOnly'))\n              return; // ace_patch\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(cm, command.toKeys, command);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!vimApi.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    var keyToKeyStack = [];\n    var noremap = false;\n    var virtualPrompt;\n    function sendKeyToPrompt(key) {\n      if (key[0] == \"<\") {\n        var lowerKey = key.toLowerCase().slice(1, -1);\n        var parts = lowerKey.split('-');\n        lowerKey = parts.pop() || '';\n        if (lowerKey == 'lt') key = '<';\n        else if (lowerKey == 'space') key = ' ';\n        else if (lowerKey == 'cr') key = '\\n';\n        else if (vimToCmKeyMap[lowerKey]) {\n          var value = virtualPrompt.value;\n          var event =  {\n            key: vimToCmKeyMap[lowerKey],\n            target: {\n              value: value,\n              selectionEnd: value.length,\n              selectionStart: value.length\n            }\n          }\n          if (virtualPrompt.onKeyDown) {\n            virtualPrompt.onKeyDown(event, virtualPrompt.value, close);\n          }\n          if (virtualPrompt && virtualPrompt.onKeyUp) {\n            virtualPrompt.onKeyUp(event, virtualPrompt.value, close);\n          }\n          return;\n        }\n      }\n      if (key == '\\n') {\n        var prompt = virtualPrompt;\n        virtualPrompt = null;\n        prompt.onClose && prompt.onClose(prompt.value);\n      } else {\n        virtualPrompt.value = (virtualPrompt.value || '') + key;\n      }\n\n      function close(value) {\n        if (typeof value == 'string') { virtualPrompt.value = value; }\n        else { virtualPrompt = null; }\n      }\n    }\n    function doKeyToKey(cm, keys, fromKey) {\n      var noremapBefore = noremap;\n      // prevent infinite recursion.\n      if (fromKey) {\n        if (keyToKeyStack.indexOf(fromKey) != -1) return;\n        keyToKeyStack.push(fromKey);\n        noremap = fromKey.noremap != false;\n      }\n\n      try {\n        var vim = maybeInitVimState(cm);\n        var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n\n        var match;\n        // Pull off one command key, which is either a single character\n        // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n        while ((match = keyRe.exec(keys))) {\n          var key = match[0];\n          var wasInsert = vim.insertMode;\n          if (virtualPrompt) {\n            sendKeyToPrompt(key);\n            continue;\n          }\n\n          var result = vimApi.handleKey(cm, key, 'mapping');\n\n          if (!result && wasInsert && vim.insertMode) {\n            if (key[0] == \"<\") {\n              var lowerKey = key.toLowerCase().slice(1, -1);\n              var parts = lowerKey.split('-');\n              lowerKey = parts.pop() || '';\n              if (lowerKey == 'lt') key = '<';\n              else if (lowerKey == 'space') key = ' ';\n              else if (lowerKey == 'cr') key = '\\n';\n              else if (vimToCmKeyMap.hasOwnProperty(lowerKey)) {\n                // todo support codemirror keys in insertmode vimToCmKeyMap\n                key = vimToCmKeyMap[lowerKey];\n                sendCmKey(cm, key);\n                continue;\n              } else {\n                key = key[0];\n                keyRe.lastIndex = match.index + 1;\n              }\n            }\n            cm.replaceSelection(key);\n          }\n        }\n      } finally {\n        keyToKeyStack.pop();\n        noremap = keyToKeyStack.length ? noremapBefore : false;\n        if (!keyToKeyStack.length && virtualPrompt) {\n          var promptOptions = virtualPrompt;\n          virtualPrompt = null;\n          showPrompt(cm, promptOptions);\n        }\n      }\n    }\n\n    var specialKey = {\n      Return: 'CR', Backspace: 'BS', 'Delete': 'Del', Escape: 'Esc', Insert: 'Ins',\n      ArrowLeft: 'Left', ArrowRight: 'Right', ArrowUp: 'Up', ArrowDown: 'Down',\n      Enter: 'CR', ' ': 'Space'\n    };\n    var ignoredKeys = { Shift: 1, Alt: 1, Command: 1, Control: 1,\n      CapsLock: 1, AltGraph: 1, Dead: 1, Unidentified: 1 };\n\n    var vimToCmKeyMap = {};\n    'Left|Right|Up|Down|End|Home'.split('|').concat(Object.keys(specialKey)).forEach(function(x) {\n      vimToCmKeyMap[(specialKey[x] || '').toLowerCase()]\n         = vimToCmKeyMap[x.toLowerCase()] = x;\n    });\n\n    function vimKeyFromEvent(e, vim) {\n      var key = e.key;\n      if (ignoredKeys[key]) return;\n      if (key.length > 1 && key[0] == \"n\") {\n        key = key.replace(\"Numpad\", \"\");\n      }\n      key = specialKey[key] || key;\n\n      var name = '';\n      if (e.ctrlKey) { name += 'C-'; }\n      if (e.altKey) { name += 'A-'; }\n      if (e.metaKey) { name += 'M-'; }\n      // on mac many characters are entered as option- combos\n      // (e.g. on swiss keyboard { is option-8)\n      // so we ignore lonely A- modifier for keypress event on mac\n      if (CodeMirror.isMac && e.altKey && !e.metaKey && !e.ctrlKey) {\n        name = name.slice(2);\n      }\n      if ((name || key.length > 1) && e.shiftKey) { name += 'S-'; }\n  \n      if (vim && !vim.expectLiteralNext && key.length == 1) {\n        if (langmap.keymap && key in langmap.keymap) {\n          if (langmap.remapCtrl != false || !name)\n            key = langmap.keymap[key];\n        } else if (key.charCodeAt(0) > 255) {\n          var code = e.code && e.code.slice(-1) || \"\";\n          if (!e.shiftKey) code = code.toLowerCase();\n          if (code) key = code;\n        }\n      }\n\n      name += key;\n      if (name.length > 1) { name = '<' + name + '>'; }\n      return name;\n    };\n\n    // langmap support\n    function updateLangmap(langmapString, remapCtrl) {\n      if (langmap.string !== langmapString) {\n        langmap = parseLangmap(langmapString);\n      }\n      langmap.remapCtrl = remapCtrl;\n    }\n    function parseLangmap(langmapString) {\n      // From :help langmap\n      /*\n        The 'langmap' option is a list of parts, separated with commas.  Each\n            part can be in one of two forms:\n            1.  A list of pairs.  Each pair is a \"from\" character immediately\n                followed by the \"to\" character.  Examples: \"aA\", \"aAbBcC\".\n            2.  A list of \"from\" characters, a semi-colon and a list of \"to\"\n                characters.  Example: \"abc;ABC\"\n      */\n\n      let keymap = {};\n      if (!langmapString) return { keymap: keymap, string: '' };\n\n      function getEscaped(list) {\n        return list.split(/\\\\?(.)/).filter(Boolean);\n      }\n      langmapString.split(/((?:[^\\\\,]|\\\\.)+),/).map(part => {\n        if (!part) return;\n        const semicolon = part.split(/((?:[^\\\\;]|\\\\.)+);/);\n        if (semicolon.length == 3) {\n          const from = getEscaped(semicolon[1]);\n          const to = getEscaped(semicolon[2]);\n          if (from.length !== to.length) return; // skip over malformed part\n          for (let i = 0; i < from.length; ++i) keymap[from[i]] = to[i];\n        } else if (semicolon.length == 1) {\n          const pairs = getEscaped(part);\n          if (pairs.length % 2 !== 0) return; // skip over malformed part\n          for (let i = 0; i < pairs.length; i += 2) keymap[pairs[i]] = pairs[i + 1];\n        }\n      });\n\n      return { keymap: keymap, string: langmapString };\n    }\n\n    defineOption('langmap', undefined, 'string', ['lmap'], function(name, cm) {\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        return langmap.string;\n      } else {\n        updateLangmap(name);\n      }\n    });\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n      this.changeQueue = null; // For restoring text used by insert mode keybindings\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      cm.state.vim.expectLiteralNext = false;\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    function ChangeQueue() {\n      this.removed = [];\n      this.inserted = \"\";\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      // ace_patch\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n      registers['+'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        if (registerName === '+' && typeof navigator !== 'undefined' &&\n          typeof navigator.clipboard !== 'undefined' &&\n          typeof navigator.clipboard.readText === 'function') {\n          navigator.clipboard.writeText(text);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && (inArray(name, validRegisters) || latinCharRegex.test(name));\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {\n            type: 'partial',\n            expectLiteralNext: matches.partial.length == 1 && matches.partial[0].keys.slice(-11) == '<character>' // langmap literal logic\n          };\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>' || bestMatch.keys.slice(-10) == '<register>') {\n          var character = lastChar(keys);\n          if (!character || character.length > 1) return {type: 'clear'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          //ace_patch cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = vimKeyFromEvent(e), up, offset;\n          if (keyName == '<Up>' || keyName == '<Down>') {\n            up = keyName == '<Up>' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n            vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = vimKeyFromEvent(e);\n          if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' ||\n              (keyName == '<BS>' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == '<Up>' || keyName == '<Down>') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == '<C-u>') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: '(JavaScript regexp)',\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, {noSymbol: true});\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, {noSymbol: false});\n              isKeyword = false;\n            }\n            if (!word) {\n              showConfirm(cm, 'No word under cursor');\n              clearInputState(cm);\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n          if (cm.state.vim) clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = vimKeyFromEvent(e), up, offset;\n          if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' ||\n              (keyName == '<BS>' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == '<Up>' || keyName == '<Down>') {\n            CodeMirror.e_stop(e);\n            up = keyName == '<Up>' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == '<C-u>') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            if (!operator && cm.ace.curOp != null)\n              cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, oldHead);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            if (cm.ace.curOp)\n              cm.ace.curOp.vimDialogScroll = \"center-animate\"; // ace_patch\n            newHead = clipCursorToContent(cm, newHead, oldHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n            cmSel = makeCmSelection(cm, {\n              anchor: newPositions.start,\n              head: newPositions.end\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n            cmSel = makeCmSelection(cm, {\n              anchor: newPositions.start,\n              head: newPositions.end\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n\n        // next: [from, to] | null\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n        // No matches.\n        if (!next) {\n          return;\n        }\n\n        // If there's an operator that will be executed, return the selection.\n        if (prevInputState.operator) {\n          return next;\n        }\n\n        // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n        var from = next[0];\n        // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n        var to = new Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n          }\n\n          // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n          var anchor = vim.sel.anchor;\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last){\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        // ace_patch{\n        var fold = cm.ace.session.getFoldLine(line);\n        if (fold) {\n          if (motionArgs.forward) {\n            if (line > fold.start.row)\n              line = fold.end.row + 1;\n          } else {\n            line = fold.start.row;\n          }\n        }\n        // ace_patch}\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n        return new Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter, head);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter, head) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return new Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n          var matched = cm.findMatchingBracket(new Pos(line, ch+1), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return new Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      moveToStartOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n      },\n      moveToEndOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\") head.ch--;\n        return head;\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp, move;\n        if (mirroredPairs[character]) {\n          move = true;\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n          if (!tmp) {\n            var sc = cm.getSearchCursor(new RegExp(\"\\\\\" + character, \"g\"), head)\n            if (sc.find()) {\n              tmp = selectCompanionObject(cm, sc.from(), character, inclusive);\n            }\n          }\n        } else if (selfPaired[character]) {\n          move = true;\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W' || character === 'w') {\n          var repeat = motionArgs.repeat || 1;\n          while (repeat-- > 0) {\n            var repeated = expandWordUnderCursor(cm, {\n              inclusive,\n              innerWord: !inclusive,\n              bigWord: character === 'W',\n              noSymbol: character === 'W',\n              multiline: true\n            }, tmp && tmp.end);\n            if (repeated) {\n              if (!tmp) tmp = repeated;\n              tmp.end = repeated.end;\n            }\n          }\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else if (character === 's') {\n          // account for cursor on end of sentence symbol\n          var content = cm.getLine(head.line);\n          if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n            head.ch -= 1;\n          }\n          var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive)\n          var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive)\n          // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n          if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n              && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n            start = {line: start.line, ch: start.ch + 1}\n          }\n          tmp = {start: start, end: end};\n        }\n\n        if (!tmp) {\n          // No valid text object, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end, move);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          if (args.linewise) {\n            anchor = new Pos(anchor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(anchor.line)));\n            if (head.line > anchor.line) {\n              head = new Pos(head.line - 1, Number.MAX_VALUE)\n            }\n          }\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head)\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          for (var j = 0; j < repeat; j++) {\n            if (args.indentRight) cm.indentMore();\n            else cm.indentLess();\n          }\n        } else {\n          var startLine = ranges[0].anchor.line;\n          var endLine = vim.visualBlock ?\n            ranges[ranges.length - 1].anchor.line :\n            ranges[0].head.line;\n          // In visual mode, n> shifts the selection right n times, instead of\n          // shifting n lines right once.\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          if (args.linewise) {\n            // The only way to delete a newline is to delete until the start of\n            // the next line, so in linewise mode evalInput will include the next\n            // line. We don't want this in indent, so we go back a line.\n            endLine--;\n          }\n          for (var i = startLine; i <= endLine; i++) {\n            for (var j = 0; j < repeat; j++) {\n              cm.indentLine(i, args.indentRight);\n            }\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      hardWrap: function(cm, operatorArgs, ranges, oldAnchor, newHead) {\n        if (!cm.hardWrap) return;\n        var from = ranges[0].anchor.line;\n        var to = ranges[0].head.line;\n        if (operatorArgs.linewise) to--;\n        var endRow = cm.hardWrap({from: from, to: to});\n        if (endRow > from && operatorArgs.linewise) endRow--;\n        return operatorArgs.keepCursor ? oldAnchor : new Pos(endRow, 0);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n        cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n          case 'center': y = charCoords.bottom - height / 2;\n            break;\n          case 'bottom':\n            var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n            var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n            var lineHeight = lineLastCharCoords.bottom - y;\n            y = y - height + lineHeight\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = new Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = new Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n          head = newPosition.end;\n        } else if (insertAt == 'firstNonBlank') {\n          var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n          head = newPosition.end;\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch, sel.anchor.ch) + 1);\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          if (vim.insertEnd) vim.insertEnd.clear();\n          vim.insertEnd = cm.setBookmark(head, {insertLeft: true});\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n          var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head)\n          vim.sel = {\n            anchor: newPosition.start,\n            head: newPosition.end\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var text = '';\n          var nextStartCh = 0;\n          if (!actionArgs.keepSpaces) {\n            var nextLine = cm.getLine(curStart.line + 1);\n            nextStartCh = nextLine.search(/\\S/);\n            if (nextStartCh == -1) {\n              nextStartCh = nextLine.length;\n            } else {\n              text = \" \";\n            }\n          }\n          cm.replaceRange(text, \n            new Pos(curStart.line, finalCh),\n            new Pos(curStart.line + 1, nextStartCh));\n        }\n        var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var fallback = () => {\n          var text = register.toString();\n          this.continuePaste(cm, actionArgs, vim, text, register);\n        }\n        if (actionArgs.registerName === '+' &&\n              typeof navigator !== 'undefined' &&\n              typeof navigator.clipboard !== 'undefined' &&\n              typeof navigator.clipboard.readText === 'function') {\n          navigator.clipboard.readText().then((value) => {\n            this.continuePaste(cm, actionArgs, vim, value, register);\n          }, () => { fallback() })\n        } else {\n          fallback()\n        }\n      },\n      continuePaste: function(cm, actionArgs, vim, text, register) {\n        var cur = copyCursor(cm.getCursor());\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n            text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  new Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, new Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise) {\n              var line = actionArgs.after ? cur.line + 1 : cur.line;\n              curPosFinal = new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n            } else {\n              curPosFinal = copyCursor(cur);\n              if (!/\\n/.test(text)) {\n                curPosFinal.ch += text.length - (actionArgs.after ? 1 : 0);\n              }\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      insertRegister: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var register = vimGlobalState.registerController.getRegister(registerName);\n        var text = register && register.toString();\n        if (text) {\n          cm.replaceSelection(text);\n        }\n      },\n      oneNormalCommand: function(cm, actionArgs, vim) {\n        exitInsertMode(cm, true);\n        vim.insertModeReturn = true;\n        CodeMirror.on(cm, 'vim-command-done', function handler() {\n          if (vim.visualMode) return;\n          if (vim.insertModeReturn) {\n            vim.insertModeReturn = false;\n            if (!vim.insertMode) {\n              actions.enterInsertMode(cm, {}, vim);\n            }\n          }\n          CodeMirror.off(cm, 'vim-command-done', handler);\n        });\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = new Pos(curStart.line, replaceTo);\n        }\n\n        var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n        curStart = newPositions.start;\n        curEnd = newPositions.end;\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          // replace all surrogate characters with selected character\n          replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4]\n          var digits = match[3] || match[5]\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = new Pos(cur.line, start);\n          var to = new Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * and is not inside surrogate pair\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, oldCur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var text = cm.getLine(line);\n      var maxCh = text.length - 1 + Number(!!includeLineBreak);\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      // prevent cursor from entering surrogate pair\n      var charCode = text.charCodeAt(ch);\n      if (0xDC00 <= charCode && charCode <= 0xDFFF) {\n        var direction = 1;\n        if (oldCur && oldCur.line == line && oldCur.ch > ch) {\n          direction = -1;\n        }\n        ch +=direction;\n        if (ch > maxCh) ch -=2;\n      }\n      return new Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      if (inputState.operator) context = \"operatorPending\";\n      var match, partial = [], full = [];\n      // if currently expanded key comes from a noremap, searcg only in default keys\n      var startIndex = noremap ? keyMap.length - defaultKeymapLength : 0;\n      for (var i = startIndex; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            (command.context && command.context != context) ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      const isLastCharacter = mapped.slice(-11) == '<character>';\n      const isLastRegister = mapped.slice(-10) == '<register>';\n      if (isLastCharacter || isLastRegister) {\n        // Last character matches anything.\n        var prefixLen = mapped.length - (isLastCharacter ? 11 : 10);\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return new Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(new Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = new Pos(i, selectionStart.ch);\n            var head = new Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = new Pos(selectionStart.line, 0);\n            selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end, move) {\n      var sel = cm.state.vim.sel;\n      var head = move ? start: sel.head;\n      var anchor = move ? start: sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            fromCh = anchor.ch,\n            bottom = Math.max(anchor.line, head.line),\n            toCh = head.ch;\n        if (fromCh < toCh) { toCh += 1 }\n        else { fromCh += 1 };\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: new Pos(top + i, fromCh),\n            head: new Pos(top + i, toCh)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, {inclusive, innerWord, bigWord, noSymbol, multiline}, cursor) {\n      var cur = cursor || getHead(cm);\n      var line = cm.getLine(cur.line);\n      var endLine = line;\n      var startLineNumber = cur.line\n      var endLineNumber = startLineNumber;\n      var idx = cur.ch;\n\n      var wordOnNextLine;\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      if (innerWord && /\\s/.test(line.charAt(idx))) {\n        test = function(ch) { return /\\s/.test(ch); };\n      } else {\n        while (!test(line.charAt(idx))) {\n          idx++;\n          if (idx >= line.length) {\n            if (!multiline) return null;\n            idx--;\n            wordOnNextLine = findWord(cm, cur, true, bigWord, true);\n            break\n          }\n        }\n\n        if (bigWord) {\n          test = bigWordCharTest[0];\n        } else {\n          test = wordCharTest[0];\n          if (!test(line.charAt(idx))) {\n            test = wordCharTest[1];\n          }\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n      if (wordOnNextLine) {\n        end = wordOnNextLine.to;\n        endLineNumber = wordOnNextLine.line;\n        endLine = cm.getLine(endLineNumber);\n        if (!endLine && end == 0) end++;\n      } else {\n        while (test(line.charAt(end)) && end < line.length) { end++; }\n      }\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        var startsWithSpace = cur.ch <= start && /\\s/.test(line.charAt(cur.ch));\n        if (!startsWithSpace) {\n          while (/\\s/.test(endLine.charAt(end)) && end < endLine.length) { end++; }\n        }\n        if (wordEnd == end || startsWithSpace) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start && !startsWithSpace) { start = wordStart; }\n        }\n      }\n\n      return { start: new Pos(startLineNumber, start), end: new Pos(endLineNumber, end) };\n    }\n\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n      if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n      }\n\n      if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n      }\n      return { start: tags.open.to, end: tags.close.from };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return new Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end=cm.clipPos(retval);\n      end.ch--;\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n      }\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character, head) {\n      var cur = head || cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return new Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, new Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks) && !latinCharRegex.test(markName)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !/\\S/.test(cm.getLine(i)); } // ace_patch\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      function skipFold(i) {\n          dir = dir > 0 ? 1 : -1;\n          var foldLine = cm.ace.session.getFoldLine(i);\n          if (foldLine) {\n              if (i + dir > foldLine.start.row && i + dir < foldLine.end.row)\n                  dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n          }\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          skipFold(i);\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    /**\n     * Based on {@link findSentence}. The internal functions have the same names,\n     * but their behaviour is different. findSentence() crosses line breaks and \n     * is used for jumping to sentence beginnings before or after the current cursor position, \n     * whereas getSentence() is for getting the beginning or end of the sentence \n     * at the current cursor position, either including (a) or excluding (i) whitespace.\n     */\n    function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the pos member to represent the\n        next valid position or sets the line to null if there are\n        no more valid positions.\n       */\n      function nextChar(curr) {\n        if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n          curr.line = null;\n        }\n        else {\n          curr.pos += curr.dir;\n        }\n      }\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the sentence end\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        if (curr.line === \"\") {\n          return { ln: curr.ln, pos: curr.pos };\n        }\n\n        var lastSentencePos = curr.pos;\n\n        // Move one step to skip character we start on\n        nextChar(curr);\n\n        while (curr.line !== null) {\n          lastSentencePos = curr.pos;\n          if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n            if (!inclusive) {\n              return { ln: curr.ln, pos: curr.pos + 1 };\n            } \n            else {\n              nextChar(curr);\n              while (curr.line !== null ) {\n                if (isWhiteSpaceString(curr.line[curr.pos])) {\n                  lastSentencePos = curr.pos;\n                  nextChar(curr)\n                } \n                else {\n                  break;\n                }\n              }\n              return { ln: curr.ln, pos: lastSentencePos + 1 };\n            }\n          }\n          nextChar(curr);\n        }\n        return { ln: curr.ln, pos: lastSentencePos + 1 };\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the sentence start\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        if (curr.line === \"\") {\n          return { ln: curr.ln, pos: curr.pos };\n        }\n\n        var lastSentencePos = curr.pos;\n\n        // Move one step to skip character we start on\n        nextChar(curr);\n\n        while (curr.line !== null) {\n          if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n            lastSentencePos = curr.pos;\n          }\n\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n            if (!inclusive) {\n              return { ln: curr.ln, pos: lastSentencePos };\n            } \n            else {\n              if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                return { ln: curr.ln, pos: curr.pos + 1 };\n              } \n              else {\n                return { ln: curr.ln, pos: lastSentencePos };\n              }\n            }\n          }\n\n          nextChar(curr);\n        }\n        curr.line = line\n        if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n          return { ln: curr.ln, pos: curr.pos };\n        } \n        else {\n          return { ln: curr.ln, pos: lastSentencePos };\n        }\n\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n\n       /*\n         Takes an index object\n         {\n           line: the line string,\n           ln: line number,\n           pos: index in line,\n           dir: direction of traversal (-1 or 1)\n         }\n         and modifies the line, ln, and pos members to represent the\n         next valid position or sets them to null if there are\n         no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        }\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos }\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) return null;\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        var stringAfter = /string/.test(cm.getTokenTypeAt(offsetCursor(head, 0, 1)));\n        var stringBefore = /string/.test(cm.getTokenTypeAt(head));\n        var isStringStart = stringAfter && !stringBefore\n        if (!isStringStart) {\n          end = cur.ch; // assign end to the current cursor\n          --cur.ch; // make sure to look backwards\n        }\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n      return regexp;\n    }\n\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);\n        else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n      }\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n      if (cm.openNotification) {\n        cm.openNotification(pre, {bottom: true, duration: 5000});\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom('div', {$display: 'flex'},\n               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre', $flex: 1},\n                 prefix,\n                 dom('input', {type: 'text', autocorrect: 'off',\n                               autocapitalize: 'off', spellcheck: 'false', $width: '100%'})),\n               desc && dom('span', {$color: '#888'}, desc));\n    }\n\n    function showPrompt(cm, options) {\n      if (keyToKeyStack.length) {\n        if (!options.value) options.value = '';\n        virtualPrompt = options;\n        return;\n      }\n      var template = makePrompt(options.prefix, options.desc);\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n          bottom: true, selectValueOnOpen: false, value: options.value\n        });\n      }\n      else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n        if (options.desc) shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      var searchState = getSearchState(cm);\n      searchState.highlightTimeout = highlightTimeout;\n      highlightTimeout = setTimeout(function() {\n        if (!cm.state.vim) return;\n        var searchState = getSearchState(cm);\n        searchState.highlightTimeout = null;\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                found = cursor.find(prev);\n            }\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        // Go back one result to ensure that if the cursor is currently a match, we keep it.\n        var found = cursor.find(!prev);\n\n        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return [cursor.from(), cursor.to()];\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      if (state.highlightTimeout) {\n        clearTimeout(state.highlightTimeout);\n        state.highlightTimeout = null;\n      }\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      // ace_patch{\n      var renderer = cm.ace.renderer;\n      return {\n        top: renderer.getFirstFullyVisibleRow(),\n        bottom: renderer.getLastFullyVisibleRow()\n      }\n      // ace_patch}\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      if (cm.getLastEditEnd) {\n        return cm.getLastEditEnd();\n      }\n      // for old cm\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              doKeyToKey(cm, command.toKeys, command);\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        if (result.line == undefined) {\n          if (cm.state.vim.visualMode) {\n            var pos = getMarkPos(cm, cm.state.vim, '<');\n            result.selectionLine = pos && pos.line;\n            pos = getMarkPos(cm, cm.state.vim, '>');\n            result.selectionLineEnd = pos && pos.line;\n          } else {\n            result.selectionLine = cm.getCursor().line;\n          }\n        } else {\n          result.selectionLine = result.line;\n          result.selectionLineEnd = result.lineEnd;\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx, noremap) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          // Key to key or ex mapping\n          var mapping = {\n            keys: lhs,\n            type: 'keyToKey',\n            toKeys: rhs,\n            noremap: !!noremap\n          };\n          if (ctx) { mapping.context = ctx; }\n          defaultKeymap.unshift(mapping);\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return true;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx, defaultOnly) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx, defaultOnly);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      omap: function(cm, params) { this.map(cm, params, 'operatorPending'); },\n      noremap: function(cm, params) { this.map(cm, params, undefined, true); },\n      inoremap: function(cm, params) { this.map(cm, params, 'insert', true); },\n      nnoremap: function(cm, params) { this.map(cm, params, 'normal', true); },\n      vnoremap: function(cm, params) { this.map(cm, params, 'visual', true); },\n      onoremap: function(cm, params) { this.map(cm, params, 'operatorPending', true); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n        }\n      },\n      mapclear: function(cm, params) { vimApi.mapclear(); },\n      imapclear: function(cm, params) { vimApi.mapclear('insert'); },\n      nmapclear: function(cm, params) { vimApi.mapclear('normal'); },\n      vmapclear: function(cm, params) { vimApi.mapclear('visual'); },\n      omapclear: function(cm, params) { vimApi.mapclear('operatorPending'); },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n        var forceToggle = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        } else if (optionName.charAt(optionName.length - 1) == '!') {\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceToggle = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean) {\n          if (forceToggle) {\n            value = !getOption(optionName, cm, setCfg);\n          } else if (value == undefined) {\n            // Calling set with a boolean option sets it to true.\n            value = true;\n          }\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n'\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n'\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      normal: function(cm, params) {\n        var argString = params.argString;\n        if (argString && argString[0] == '!') {\n            argString = argString.slice(1);\n            noremap = true;\n        }\n        argString = argString.trimStart();\n        if (!argString) {\n          showConfirm(cm, 'Argument is required.');\n          return;\n        }\n        var line = params.line;\n        if (typeof line == 'number') {\n          var lineEnd = isNaN(params.lineEnd) ? line : params.lineEnd;\n          for (var i = line; i <= lineEnd; i++) {\n            cm.setCursor(i, 0);\n            doKeyToKey(cm, params.argString.trimStart());\n            if (cm.state.vim.insertMode) {\n              exitInsertMode(cm, true);\n            }\n          }\n        } else {\n          doKeyToKey(cm, params.argString.trimStart());\n          if (cm.state.vim.insertMode) {\n            exitInsertMode(cm, true);\n          }\n        }\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        if (argString[0] === '!' && params.commandName[0] === 'g') {\n          inverted = true;\n          argString = argString.slice(1);\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLine(i);\n          var matched = query.test(line);\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? cm.getLineHandle(i) : line);\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var lineHandle = matchedLines[index++];\n            var lineNum = cm.getLineNumber(lineHandle);\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n            var command = (lineNum + 1) + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          } else if (cm.releaseLineHandles) {\n            cm.releaseLineHandles();\n          }\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      startinsert: function(cm, params) {\n        doKeyToKey(cm, params.argString == '!' ? 'A' : 'i', {});\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delete: function(cm, params) {\n        var line = params.selectionLine;\n        var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n        operators.delete(cm, {linewise: true}, [\n          { anchor: new Pos(line, 0),\n            head: new Pos(lineEnd + 1, 0) }\n        ]);\n      },\n      join: function(cm, params) {\n        var line = params.selectionLine;\n        var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n        cm.setCursor(new Pos(line, 0));\n        actions.joinLines(cm, {repeat: lineEnd - line}, cm.state.vim);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n        return match;\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(findNextValidMatch() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = vimKeyFromEvent(e);\n        switch (keyName) {\n          case 'y':\n            replace(); next(); break;\n          case 'n':\n            next(); break;\n          case 'a':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'l':\n            replace();\n            // fall through and exit.\n          case 'q':\n          case '<Esc>':\n          case '<C-c>':\n          case '<C-[>':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    function exitInsertMode(cm, keepCursor) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = null;\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      if (!keepCursor) {\n        cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      }\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        var vim = cm.state.vim;\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                if (text.length > 1) {\n                  var insertEnd = vim && vim.insertEnd && vim.insertEnd.find()\n                  var cursor = cm.getCursor();\n                  if (insertEnd && insertEnd.line == cursor.line) {\n                    var offset = insertEnd.ch - cursor.ch;\n                    if (offset > 0 && offset < text.length) {\n                      lastChange.changes.push([text, offset]);\n                      text = '';\n                    }\n                  }\n                }\n                if (text) lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n          if (vim.insertEnd) vim.insertEnd.clear();\n          vim.insertEnd = cm.setBookmark(cm.getCursor(), {insertLeft: true});\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n    }\n    function handleExternalSelection(cm, vim, keepHPos) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode && !keepHPos) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName, e) {\n      this.keyName = keyName;\n      this.key = e.key;\n      this.ctrlKey = e.ctrlKey;\n      this.altKey = e.altKey;\n      this.metaKey = e.metaKey;\n      this.shiftKey = e.shiftKey;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName ? CodeMirror.keyName(e) : e.key;\n      if (!keyName) { return; }\n      \n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName, e));\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function sendCmKey(cm, key) {\n      CodeMirror.lookupKey(key, 'vim-insert', function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      });\n    }\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            sendCmKey(cm, change.keyName, change);\n          } else if (typeof change == \"string\") {\n            cm.replaceSelection(change);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length - (change[1] || 0));\n            cm.replaceRange(change[0], start, change[1] ? start: end);\n            cm.setCursor(end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    // multiselect support\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = vimApi;\n\n  var specialKeyAce = {'return':'CR',backspace:'BS','delete':'Del',esc:'Esc',\n    left:'Left',right:'Right',up:'Up',down:'Down',space: 'Space',insert: 'Ins',\n    home:'Home',end:'End',pageup:'PageUp',pagedown:'PageDown', enter: 'CR'\n  };\n  function lookupKey(hashId, key, e, vim) {\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"numpad\", \"\");\n    }\n    key = specialKeyAce[key] || key;\n    var name = '';\n    if (e.ctrlKey) { name += 'C-'; }\n    if (e.altKey) { name += 'A-'; }\n    if ((name || key.length > 1) && e.shiftKey) { name += 'S-'; }\n\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n      if (langmap.keymap && key in langmap.keymap) {\n        if (langmap.remapCtrl !== false || !name)\n          key = langmap.keymap[key];\n      } else if (key.charCodeAt(0) > 255) {\n        var code = e.code && e.code.slice(-1) || \"\";\n        if (!e.shiftKey) code = code.toLowerCase();\n        if (code) key = code;\n      }\n    }\n\n    name += key;\n    if (name.length > 1) { name = '<' + name + '>'; }\n    return name;\n  }\n  var handleKey = vimApi.handleKey.bind(vimApi);\n  vimApi.handleKey = function(cm, key, origin) {\n    return cm.operation(function() {\n      return handleKey(cm, key, origin);\n    }, true);\n  }\n    function cloneVimState(state) {\n      var n = new state.constructor();\n      Object.keys(state).forEach(function(key) {\n        if (key == \"insertEnd\") return;\n        var o = state[key];\n        if (Array.isArray(o))\n          o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n          o = cloneVimState(o);\n        n[key] = o;\n      });\n      if (state.sel) {\n        n.sel = {\n          head: state.sel.head && copyCursor(state.sel.head),\n          anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n      }\n      return n;\n    }\n    function multiSelectHandleKey(cm, key, origin) {\n      var isHandled = false;\n      var vim = vimApi.maybeInitVimState_(cm);\n      var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n      var wasMultiselect = cm.ace.inMultiSelectMode;\n      if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n      } else if (wasMultiselect && vim.visualBlock) {\n         vim.wasInVisualBlock = true;\n      }\n\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n      cm.ace.exitMultiSelectMode();\n    } else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n      isHandled = vimApi.handleKey(cm, key, origin);\n      } else {\n        var old = cloneVimState(vim);\n        var changeQueueList = vim.inputState.changeQueueList || [];\n\n        cm.operation(function() {\n          cm.curOp.isVimOp = true;\n          var index = 0;\n          cm.ace.forEachSelection(function() {\n            var sel = cm.ace.selection;\n            cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n            cm.state.vim.inputState.changeQueue = changeQueueList[index];\n            var head = cm.getCursor(\"head\");\n            var anchor = cm.getCursor(\"anchor\");\n            var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n            var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n            head = offsetCursor(head, 0, headOffset);\n            anchor = offsetCursor(anchor, 0, anchorOffset);\n            cm.state.vim.sel.head = head;\n            cm.state.vim.sel.anchor = anchor;\n\n            isHandled = handleKey(cm, key, origin);\n            sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n            // TODO why does cm.virtualSelectionMode check index?\n            if (cm.ace.inVirtualSelectionMode) {\n              changeQueueList[index] = cm.state.vim.inputState.changeQueue;\n            }\n            if (cm.virtualSelectionMode()) {\n              cm.state.vim = cloneVimState(old);\n            }\n            index++;\n          });\n          if (cm.curOp.cursorActivity && !isHandled)\n            cm.curOp.cursorActivity = false;\n          vim.status = cm.state.vim.status;\n          cm.state.vim = vim;\n          vim.inputState.changeQueueList = changeQueueList;\n          vim.inputState.changeQueue = null;\n        }, true);\n      }\n      // some commands may bring visualMode and selection out of sync\n      if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim, true);\n      }\n      return isHandled;\n    }\n    resetVimGlobalState();\n\n\n  exports.CodeMirror = CodeMirror;\n  var getVim = vimApi.maybeInitVimState_;\n  exports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function(element, pixelPos, config, sel, session) {\n      var vim = this.state.vim || {};\n      var w = config.characterWidth;\n      var h = config.lineHeight;\n      var top = pixelPos.top;\n      var left = pixelPos.left;\n      if (!vim.insertMode) {\n        var isbackwards = !sel.cursor\n            ? session.selection.isBackwards() || session.selection.isEmpty()\n            : Range.comparePoints(sel.cursor, sel.start) <= 0;\n        if (!isbackwards && left > w)\n          left -= w;\n      }\n      if (!vim.insertMode && vim.status) {\n        h = h / 2;\n        top += h;\n      }\n      domLib.translate(element, left, top);\n      domLib.setStyle(element.style, \"width\", w + \"px\");\n      domLib.setStyle(element.style, \"height\", h + \"px\");\n    },\n    $getDirectionForHighlight: function (editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (!vim.insertMode) {\n        return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();\n      }\n    },\n    handleKeyboard: function(data, hashId, key, keyCode, e) {\n      var editor = data.editor;\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (keyCode == -1) return;\n\n      // in non-insert mode we try to find the ascii key corresponding to the text in textarea\n      // this is needed because in languages that use latin alphabet we want to get the key that browser sends to the textarea\n      // and in non\n      if (!vim.insertMode) {\n        if (hashId == -1) {\n          if (key.charCodeAt(0) > 0xFF) {\n            if (data.inputKey) {\n              key = data.inputKey;\n              if (key && data.inputHash == 4)\n                key = key.toUpperCase();\n            }\n          }\n          data.inputChar = key;\n        }\n        else if (hashId == 4 || hashId == 0) {\n          if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n            // on mac text input doesn't repeat\n            key = data.inputChar;\n            hashId = -1\n          }\n          else {\n            data.inputChar = null;\n            data.inputKey = key;\n            data.inputHash = hashId;\n          }\n        }\n        else {\n          data.inputChar = data.inputKey = null;\n        }\n      }\n      \n      if (cm.state.overwrite && vim.insertMode && key == \"backspace\" && hashId == 0) {\n        return {command: \"gotoleft\"}\n      }\n\n      // ctrl-c is special it both exits mode and copies text\n      if (key == \"c\" && hashId == 1) { // key == \"ctrl-c\"\n        if (!useragent.isMac && editor.getCopyText()) {\n          editor.once(\"copy\", function() {\n            if (vim.insertMode) editor.selection.clearSelection();\n            else cm.operation(function() { exitVisualMode(cm); });\n          });\n          return {command: \"null\", passEvent: true};\n        }\n      }\n\n      if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (overlay) cm.removeOverlay(overlay);\n      }\n\n      if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n        var insertMode = vim.insertMode;\n        var name = lookupKey(hashId, key, e || {}, vim);\n        if (vim.status == null)\n          vim.status = \"\";\n        var isHandled = multiSelectHandleKey(cm, name, 'user');\n        vim = getVim(cm); // may be changed by multiSelectHandleKey\n        if (isHandled && vim.status != null)\n          vim.status += name;\n        else if (vim.status == null)\n          vim.status = \"\";\n        cm._signal(\"changeStatus\");\n        if (!isHandled && (hashId != -1 || insertMode))\n          return;\n        return {command: \"null\", passEvent: !isHandled};\n      }\n    },\n    attach: function(editor) {\n      if (!editor.state) editor.state = {};\n      var cm = new CodeMirror(editor);\n      editor.state.cm = cm;\n      editor.$vimModeHandler = this;\n      enterVimMode(cm);\n      getVim(cm).status = null;\n      cm.on('vim-command-done', function() {\n        if (cm.virtualSelectionMode()) return;\n        getVim(cm).status = null;\n        cm.ace._signal(\"changeStatus\");\n        cm.ace.session.markUndoGroup();\n      });\n      cm.on(\"changeStatus\", function() {\n        cm.ace.renderer.updateCursor();\n        cm.ace._signal(\"changeStatus\");\n      });\n      cm.on(\"vim-mode-change\", function() {\n        if (cm.virtualSelectionMode()) return;\n        updateInputMode();\n        cm._signal(\"changeStatus\");\n      });\n      function updateInputMode() {\n        var isIntsert = getVim(cm).insertMode;\n        cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n        editor.textInput.setCommandMode(!isIntsert);\n        // without this press and hodl popup in mac is shown in normal mode\n        editor.renderer.$keepTextAreaAtCursor = isIntsert;\n        editor.renderer.$blockCursor = !isIntsert;\n      }\n      updateInputMode();\n      editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function(editor) {\n      var cm = editor.state.cm;\n      leaveVimMode(cm);\n      cm.destroy();\n      editor.state.cm = null;\n      editor.$vimModeHandler = null;\n      editor.renderer.$cursorLayer.drawCursor = null;\n      editor.renderer.setStyle(\"normal-mode\", false);\n      editor.textInput.setCommandMode(false);\n      editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function(editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (vim.insertMode)\n        return \"INSERT\";\n      var status = \"\";\n      if (vim.visualMode) {\n        status += \"VISUAL\";\n        if (vim.visualLine)\n          status += \" LINE\";\n        if (vim.visualBlock)\n          status += \" BLOCK\";\n      }\n      if (vim.status)\n        status += (status ? \" \" : \"\") + vim.status;\n      return status;\n    }\n  };\n  vimApi.defineOption({\n    name: \"wrap\",\n    set: function(value, cm) {\n      if (cm) {cm.ace.setOption(\"wrap\", value)}\n    },\n    type: \"boolean\"\n  }, false);\n  vimApi.defineEx('write', 'w', function() {\n    console.log(':write is not implemented')\n  });\n  defaultKeymap.push(\n    { keys: 'zc', type: 'action', action: 'fold', actionArgs: { open: false } },\n    { keys: 'zC', type: 'action', action: 'fold', actionArgs: { open: false, all: true } },\n    { keys: 'zo', type: 'action', action: 'fold', actionArgs: { open: true } },\n    { keys: 'zO', type: 'action', action: 'fold', actionArgs: { open: true, all: true } },\n    { keys: 'za', type: 'action', action: 'fold', actionArgs: { toggle: true } },\n    { keys: 'zA', type: 'action', action: 'fold', actionArgs: { toggle: true, all: true } },\n    { keys: 'zf', type: 'action', action: 'fold', actionArgs: { open: true, all: true } },\n    { keys: 'zd', type: 'action', action: 'fold', actionArgs: { open: true, all: true } },\n\n    { keys: '<C-A-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAbove\" } },\n    { keys: '<C-A-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelow\" } },\n    { keys: '<C-A-S-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAboveSkipCurrent\" } },\n    { keys: '<C-A-S-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelowSkipCurrent\" } },\n    { keys: '<C-A-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreBefore\" } },\n    { keys: '<C-A-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreAfter\" } },\n    { keys: '<C-A-S-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextBefore\" } },\n    { keys: '<C-A-S-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextAfter\" } }\n  );\n  \n  defaultKeymap.push({\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n  });\n  vimApi.defineOperator(\"hardWrap\", function(cm, operatorArgs, ranges, oldAnchor, newHead) {\n    var anchor = ranges[0].anchor.line;\n    var head = ranges[0].head.line;\n    if (operatorArgs.linewise) head--;\n    hardWrap(cm.ace, {startRow: anchor, endRow: head});\n    return Pos(head, 0);\n  });\n  defineOption('textwidth', undefined, 'number', ['tw'], function(width, cm) {\n    // Option is local. Do nothing for global.\n    if (cm === undefined) {\n      return;\n    }\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (width === undefined) {\n      var value = cm.ace.getOption('printMarginColumn');\n      return value;\n    } else {\n      var column = Math.round(width);\n      if (column > 1) {\n        cm.ace.setOption('printMarginColumn', column);\n      }\n    }\n  });\n    \n  actions.aceCommand = function(cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode)\n      cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);\n    else\n      delayedExecAceCommand(null, cm.ace);\n  };\n  function delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n    if (cmd) {\n      ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n    ace.curOp = ace.prevOp;\n  }\n  actions.fold = function(cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'\n      ][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n  };\n\n  defaultKeymapLength = defaultKeymap.length; // ace_patch\n\n  exports.handler.defaultKeymap = defaultKeymap;\n  exports.handler.actions = actions;\n  exports.Vim = vimApi;\n"],"names":["Range","require","hardWrap","editor","options","max","column","getOption","allowMerge","row","Math","min","startRow","endRow","session","line","getLine","length","space","findSpace","indentation","exec","replace","start","end","test","nextLine","trimmedLine","trimmedNextLine","mergedLine","replaceRange","remove","before","slice","after","spaceAfter","spaceBefore","index","wrapAfterInput","e","command","name","args","cursor","selection","renderer","$printMarginColumn","lastDelta","$undoManager","$lastDelta","markUndoGroup","Editor","prototype","set","val","this","commands","on","off","value","exports","EventEmitter","domLib","oop","KEYS","event","Search","useragent","SearchHighlight","multiSelectCommands","TextModeTokenRe","tokenRe","CodeMirror","ace","state","marks","$uid","onChange","bind","onSelectionChange","onBeforeEndOperation","toAcePos","cmPos","ch","toCmPos","acePos","Pos","defineOption","setter","redo","cm","undo","newlineAndIndent","insert","goLineLeft","moveCursorLineStart","goLineRight","moveCursorLineEnd","keyMap","addClass","rmClass","e_stop","e_preventDefault","stopEvent","keyName","key","keyCode","toUpperCase","getModifierString","m","cmd","commandKeyBinding","toLowerCase","execCommand","lookupKey","map","handle","found","fallthrough","Array","isArray","i","result","findMatchingTag","head","findEnclosingTag","signal","o","_signal","addListener","removeListener","isWordChar","lastIndex","implement","destroy","removeOverlay","virtualSelectionMode","inVirtualSelectionMode","delta","$lineHandleChanges","push","change","text","action","lines","curOp","changeHandlers","_eventRegistry","lastChange","next","$updateMarkers","cursorActivityHandlers","cursorActivity","inMultiSelectMode","keyBinding","removeKeyboardHandler","keyboardHandler","operation","fn","force","prevOp","startOperation","scrollIntoView","dialog","vimDialogScroll","endOperation","op","eventName","handlers","listeners","firstLine","lastLine","getLength","lineCount","setCursor","shouldScroll","exitMultiSelectMode","unfold","moveTo","scrollCursorIntoView","getCursor","p","sel","pos","isEmpty","lead","anchor","getRange","listSelections","ranges","multiSelect","rangeList","r","clipPos","setSelections","primIndex","x","comparePoints","fromPoints","fromOrientedRange","splice","reverse","toSingleRange","clone","range","$clipRangeToDocument","addRange","setSelection","a","h","selectTo","origin","somethingSelected","$clipPositionToDocument","foldCode","$toggleFoldWidget","markText","clear","find","isInsert","rowShift","colShift","point","cmp","$insertRight","bias","cmp2","Marker","id","setBookmark","bm","insertLeft","moveH","increment","unit","clearSelection","moveCursorBy","findPosV","amount","goalColumn","config","layerConfig","floor","height","lineHeight","screenPos","documentToScreenPosition","getScreenLength","screenToDocumentPosition","charCoords","mode","sc","left","top","lh","cw","characterWidth","bottom","coordsChar","col","getSearchCursor","query","caseFold","caseSensitive","isRegexp","RegExp","global","ignoreCase","source","search","undefined","Number","MAX_VALUE","last","findNext","findPrevious","back","setOptions","needle","wrap","backwards","regExp","from","to","doc","scrollTo","y","maxHeight","$size","scrollerHeight","$scrollPastEnd","setScrollTop","setScrollLeft","width","scrollInfo","margin","viewMargin","s","getTextRange","replaceSelection","replaceSelections","strings","getSelection","getSelectedText","getSelections","getInputField","textInput","getElement","getWrapperElement","container","optMap","indentWithTabs","indentUnit","tabSize","firstLineNumber","readOnly","setOption","$keyMap","aceOpt","toggleOverwrite","overwrite","setOverwrite","addOverlay","$searchHighlight","highlight","marker","addDynamicMarker","updateOnChange","removeMarker","cache","re","setRegexp","updateBackMarkers","getScrollInfo","scrollLeft","scrollTop","clientHeight","clientWidth","getValue","setValue","v","getTokenTypeAt","token","getTokenAt","type","findMatchingBracket","getMatchingTags","open","openTag","close","closeTag","indentLine","method","indentRows","outdentRows","indexFromPos","positionToIndex","posFromIndex","indexToPosition","focus","blur","defaultTextHeight","scanForBracket","dir","_","bracketRegex","$findClosingBracket","$findOpeningBracket","refresh","resize","getMode","hasOwnProperty","console","log","getLineNumber","deltas","getLineHandle","releaseLineHandles","getLastEditEnd","undoManager","call","StringStream","string","lastColumnPos","lastColumnValue","lineStart","eol","sol","peek","charAt","eat","match","ok","eatWhile","eatSpace","skipToEnd","skipTo","indexOf","backUp","n","pattern","consume","caseInsensitive","cased","str","substr","current","hideFirstChars","inner","defineExtension","importCssString","dialogDiv","template","appendChild","document","createElement","className","innerHTML","closeNotification","newVal","currentNotificationClose","callback","closed","me","button","inp","getElementsByTagName","selectValueOnOpen","select","onInput","onKeyUp","onKeyDown","closeOnEnter","closeOnBlur","activeElement","onClose","vim","status","$loop","schedule","CHANGE_CURSOR","doneTimer","duration","setTimeout","clearTimeout","updateSelectionForSurrogateCharacters","curStart","curEnd","charCode","charCodeAt","defaultKeymap","keys","toKeys","context","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","keepCursor","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","fullLine","exitVisualBlock","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","langmap","parseLangmap","enterVimMode","onCursorActivity","maybeInitVimState","getOnPasteFn","leaveVimMode","highlightTimeout","onPasteFn","insertMode","offsetCursor","actions","enterInsertMode","upperCaseChars","numberRegex","wordCharTest","bigWordCharTest","validMarks","validRegisters","latinCharRegex","isLine","isLowerCase","k","isMatchableSymbol","isNumber","isUpperCase","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","defaultValue","aliases","Error","cfg","option","scope","local","round","vimGlobalState","lastInsertModeKeyTimer","createCircularJumpList","size","pointer","tail","buffer","add","oldCur","newCur","curMark","useNextSlot","trashMark","markPos","cursorEqual","move","offset","mark","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","insertModeReturn","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","expectLiteralNext","resetVimGlobalState","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","macroModeState","lastCharacterSearch","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","openDialog","dom","class","virtualPrompt","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","mapclear","actualLength","origLength","userKeymap","mapping","_mapCommand","contexts","j","newMapping","updateLangmap","vimKeyFromEvent","defineEx","prefix","func","exCommands","commandMap_","handleKey","findKey","multiSelectHandleKey","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","handleKeyInsertMode","keyBuffer","join","keysAreChars","commandDispatcher","matchCommand","changeQueue","window","selections","removed","ChangeQueue","inserted","cursorMin","cursorMax","here","pop","handleKeyNonInsertMode","keysMatcher","mainKey","operatorShortcut","pushRepeatDigit","isVimOp","doKeyToKey","processCommand","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","keyToKeyStack","sendKeyToPrompt","lowerKey","parts","split","vimToCmKeyMap","target","selectionEnd","selectionStart","prompt","fromKey","noremapBefore","keyRe","wasInsert","sendCmKey","promptOptions","showPrompt","specialKey","Return","Backspace","Escape","Insert","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Enter","ignoredKeys","Shift","Alt","Command","Control","CapsLock","AltGraph","Dead","Unidentified","ctrlKey","altKey","metaKey","isMac","shiftKey","keymap","remapCtrl","code","langmapString","getEscaped","list","filter","Boolean","part","semicolon","pairs","prefixRepeat","motionRepeat","reason","Register","insertModeChanges","searchQueries","registers","unnamedRegister","historyBuffer","iterator","initialPrefix","concat","Object","forEach","getRepeat","repeat","parseInt","setText","pushText","pushInsertModeChanges","pushSearchQuery","toString","isValidRegister","append","navigator","clipboard","readText","writeText","shiftNumericRegisters_","nextMatch","up","element","substring","pushInput","reset","bestMatch","matches","commandMatches","full","partial","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","shift","handleQuery","onPromptClose","desc","onPromptKeyUp","onPromptKeyDown","word","expandWordUnderCursor","noSymbol","isKeyword","showConfirm","escapeRegex","smartCase","updateSearchQuery","logSearchQuery","parsedQuery","clearSearchHighlight","exArgs","newHead","newAnchor","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","cmSel","newPositions","makeCmSelection","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","moveToBottomLine","expandToLine","_cm","cur","prev","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","subMode","goToMark","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","moveToStartOfLine","fold","getFoldLine","res","hitSide","lastCharCoords","goalCoords","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","lineText","style","matched","moveToLineOrEdgeOfDocument","lineNum","moveToStartOfDisplayLine","moveToEndOfDisplayLine","sticky","textObjectManipulation","mirroredPairs","selfPaired","selectCompanionObject","findBeginningAndEnd","repeated","innerWord","multiline","expandTagUnderCursor","content","getSentence","expandSelection","repeatLastCharacterSearch","lastSearch","fillArray","times","finalHead","replacement","lastState","indent","indentMore","indentLess","startLine","endLine","indentAuto","_args","changeCase","swapped","toSwap","yank","endPos","jumpListWalk","scroll","newPos","cursorCoords","ceil","newBottom","scrollToCursor","lineLastCharPos","lineLastCharCoords","replayMacro","executeMacroRegister","newPosition","getLastEditPos","insertEnd","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","nextStartCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","fallback","continuePaste","then","whitespaceLength","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","lastCh","extendLineToColumn","repeatFn","setRegister","insertRegister","oneNormalCommand","handler","setMark","markName","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","baseStr","digits","base","number","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","direction","ret","prop","offsetLine","offsetCh","startIndex","commandMatch","pressed","mapped","isLastCharacter","isLastRegister","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","cur3","cur1before2","cur2before3","trim","isClipped","curHead","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","headOffset","anchorOffset","fromCh","toCh","getHead","moveHead","firstNonWS","wordOnNextLine","startLineNumber","endLineNumber","idx","findWord","startsWithSpace","wordStart","tags","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","preprocess","curCh","lineLen","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","lastIndexOf","isBoundary","any","skipFold","foldLine","startState","nextChar","curr","ln","lastSentencePos","curr_index","last_valid","skip_empty_lines","bracketRegexp","openSym","curChar","len","chars","firstIndex","stringAfter","stringBefore","isStringStart","SearchState","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","stream","output","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","regexp","createTextNode","nodeType","setAttribute","pre","$color","$whiteSpace","openNotification","alert","innerText","makePrompt","$display","$fontFamily","$flex","autocorrect","autocapitalize","spellcheck","$width","shortText","textContent","regexEqual","r1","r2","props","rawQuery","matchSol","searchState","showMatchesOnScrollbar","lastEndPos","isInRange","getFirstFullyVisibleRow","getLastFullyVisibleRow","done","history","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","lineEnd","parseLineSpec_","selectionLine","selectionLineEnd","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","defaultOnly","mapArgs","imap","nmap","vmap","omap","inoremap","nnoremap","vnoremap","onoremap","imapclear","nmapclear","vmapclear","omapclear","setArgs","setCfg","expr","forceGet","forceToggle","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","parseArgs","opts","decimal","hex","octal","err","radix","numPart","textPart","matchPart","comparePatternFn","compareFn","textOld","b","anum","bnum","vglobal","normal","trimStart","isNaN","inverted","matchedLines","nextCommand","lineHandle","substitute","trailing","count","replacePart","confirm","startPos","doReplace","startinsert","write","save","nohlsearch","delete","delmarks","sym","startMark","finishMark","finish","String","fromCharCode","searchCursor","exMode","lastPos","modifiedLineNumber","joined","replaceAll","newText","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","insertModeChangeRegister","logInsertModeChange","extra","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","binding","Vim","specialKeyAce","backspace","esc","right","down","home","pageup","pagedown","enter","hashId","cloneVimState","constructor","isHandled","wasInVisualBlock","wasMultiselect","old","changeQueueList","forEachSelection","$desiredColumn","getVim","delayedExecAceCommand","vimCmd","$id","drawCursor","pixelPos","w","isbackwards","isBackwards","translate","setStyle","$getDirectionForHighlight","handleKeyboard","data","inputKey","inputHash","inputChar","getCopyText","once","passEvent","attach","updateInputMode","isIntsert","setCommandMode","$keepTextAreaAtCursor","$blockCursor","$vimModeHandler","updateCursor","$cursorLayer","detach","getStatusText","all","toggle","aceCommand"],"sourceRoot":""}