{"version":3,"file":"js/2856.1126d4ff.js","mappings":"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","sources":["webpack://admin/./node_modules/ace-code/src/mode/matching_brace_outdent.js","webpack://admin/./node_modules/ace-code/src/mode/r.js","webpack://admin/./node_modules/ace-code/src/mode/r_highlight_rules.js","webpack://admin/./node_modules/ace-code/src/mode/tex_highlight_rules.js"],"sourcesContent":["\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n","/*\n * r.js\n *\n * Copyright (C) 2009-11 by RStudio, Inc.\n *\n * The Initial Developer of the Original Code is\n * Ajax.org B.V.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Distributed under the BSD license:\n *\n * Copyright (c) 2010, Ajax.org B.V.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Ajax.org B.V. nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n *\n */\n\n   \"use strict\";\n\n   var unicode = require(\"../unicode\");\n   var Range = require(\"../range\").Range;\n   var oop = require(\"../lib/oop\");\n   var TextMode = require(\"./text\").Mode;\n   var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n   var RHighlightRules = require(\"./r_highlight_rules\").RHighlightRules;\n   var MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\n\n   var Mode = function(){\n      this.HighlightRules = RHighlightRules;\n      this.$outdent = new MatchingBraceOutdent();\n      this.$behaviour = this.$defaultBehaviour;\n   };\n   oop.inherits(Mode, TextMode);\n\n   (function() {\n      this.lineCommentStart = \"#\";\n      // todo import codeModel from RStudio\n      this.tokenRe = new RegExp(\"^[\" + unicode.wordChars + \"._]+\", \"g\");\n\n      this.nonTokenRe = new RegExp(\"^(?:[^\" + unicode.wordChars + \"._]|\\s])+\", \"g\");\n\n      /*this.$complements = {\n               \"(\": \")\",\n               \"[\": \"]\",\n               '\"': '\"',\n               \"'\": \"'\",\n               \"{\": \"}\"\n            };\n      this.$reOpen = /^[([\"'{]$/;\n      this.$reClose = /^[)\\]\"'}]$/;\n\n      this.getNextLineIndent = function(state, line, tab, tabSize, row)\n      {\n         return this.codeModel.getNextLineIndent(row, line, state, tab, tabSize);\n      };\n\n      this.allowAutoInsert = this.smartAllowAutoInsert;\n\n      this.checkOutdent = function(state, line, input) {\n         if (! /^\\s+$/.test(line))\n            return false;\n\n         return /^\\s*[\\{\\}\\)]/.test(input);\n      };\n\n      this.getIndentForOpenBrace = function(openBracePos)\n      {\n         return this.codeModel.getIndentForOpenBrace(openBracePos);\n      };\n\n      this.autoOutdent = function(state, doc, row) {\n         if (row == 0)\n            return 0;\n\n         var line = doc.getLine(row);\n\n         var match = line.match(/^(\\s*[\\}\\)])/);\n         if (match)\n         {\n            var column = match[1].length;\n            var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n            if (!openBracePos || openBracePos.row == row) return 0;\n\n            var indent = this.codeModel.getIndentForOpenBrace(openBracePos);\n            doc.replace(new Range(row, 0, row, column-1), indent);\n         }\n\n         match = line.match(/^(\\s*\\{)/);\n         if (match)\n         {\n            var column = match[1].length;\n            var indent = this.codeModel.getBraceIndent(row-1);\n            doc.replace(new Range(row, 0, row, column-1), indent);\n         }\n      };\n\n      this.$getIndent = function(line) {\n         var match = line.match(/^(\\s+)/);\n         if (match) {\n            return match[1];\n         }\n\n         return \"\";\n      };\n\n      this.transformAction = function(state, action, editor, session, text) {\n         if (action === 'insertion' && text === \"\\n\") {\n\n            // If newline in a doxygen comment, continue the comment\n            var pos = editor.getSelectionRange().start;\n            var match = /^((\\s*#+')\\s*)/.exec(session.doc.getLine(pos.row));\n            if (match && editor.getSelectionRange().start.column >= match[2].length) {\n               return {text: \"\\n\" + match[1]};\n            }\n         }\n         return false;\n      };*/\n       this.$id = \"ace/mode/r\";\n       this.snippetFileId = \"ace/snippets/r\";\n   }).call(Mode.prototype);\n   exports.Mode = Mode;\n","/*\n * r_highlight_rules.js\n *\n * Copyright (C) 2009-11 by RStudio, Inc.\n *\n * The Initial Developer of the Original Code is\n * Ajax.org B.V.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Distributed under the BSD license:\n *\n * Copyright (c) 2010, Ajax.org B.V.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Ajax.org B.V. nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n *\n */\n\n\n   var oop = require(\"../lib/oop\");\n   var lang = require(\"../lib/lang\");\n   var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n   var TexHighlightRules = require(\"./tex_highlight_rules\").TexHighlightRules;\n\n   var RHighlightRules = function()\n   {\n\n      var keywords = lang.arrayToMap(\n            (\"function|if|in|break|next|repeat|else|for|return|switch|while|try|tryCatch|stop|warning|require|library|attach|detach|source|setMethod|setGeneric|setGroupGeneric|setClass\")\n                  .split(\"|\")\n            );\n\n      var buildinConstants = lang.arrayToMap(\n            (\"NULL|NA|TRUE|FALSE|T|F|Inf|NaN|NA_integer_|NA_real_|NA_character_|\" +\n             \"NA_complex_\").split(\"|\")\n            );\n\n      // regexp must not have capturing parentheses. Use (?:) instead.\n      // regexps are ordered -> the first match is used\n\n      this.$rules = {\n         \"start\" : [\n            {\n               // Roxygen\n               token : \"comment.sectionhead\",\n               regex : \"#+(?!').*(?:----|====|####)\\\\s*$\"\n            },\n            {\n               // Roxygen\n               token : \"comment\",\n               regex : \"#+'\",\n               next : \"rd-start\"\n            },\n            {\n               token : \"comment\",\n               regex : \"#.*$\"\n            },\n            {\n               token : \"string\", // multi line string start\n               regex : '[\"]',\n               next : \"qqstring\"\n            },\n            {\n               token : \"string\", // multi line string start\n               regex : \"[']\",\n               next : \"qstring\"\n            },\n            {\n               token : \"constant.numeric\", // hex\n               regex : \"0[xX][0-9a-fA-F]+[Li]?\\\\b\"\n            },\n            {\n               token : \"constant.numeric\", // explicit integer\n               regex : \"\\\\d+L\\\\b\"\n            },\n            {\n               token : \"constant.numeric\", // number\n               regex : \"\\\\d+(?:\\\\.\\\\d*)?(?:[eE][+\\\\-]?\\\\d*)?i?\\\\b\"\n            },\n            {\n               token : \"constant.numeric\", // number with leading decimal\n               regex : \"\\\\.\\\\d+(?:[eE][+\\\\-]?\\\\d*)?i?\\\\b\"\n            },\n            {\n               token : \"constant.language.boolean\",\n               regex : \"(?:TRUE|FALSE|T|F)\\\\b\"\n            },\n            {\n               token : \"identifier\",\n               regex : \"`.*?`\"\n            },\n            {\n               onMatch : function(value) {\n                  if (keywords[value])\n                     return \"keyword\";\n                  else if (buildinConstants[value])\n                     return \"constant.language\";\n                  else if (value == '...' || value.match(/^\\.\\.\\d+$/))\n                     return \"variable.language\";\n                  else\n                     return \"identifier\";\n               },\n               regex : \"[a-zA-Z.][a-zA-Z0-9._]*\\\\b\"\n            },\n            {\n               token : \"keyword.operator\",\n               regex : \"%%|>=|<=|==|!=|\\\\->|<\\\\-|\\\\|\\\\||&&|=|\\\\+|\\\\-|\\\\*|/|\\\\^|>|<|!|&|\\\\||~|\\\\$|:\"\n            },\n            {\n               token : \"keyword.operator\", // infix operators\n               regex : \"%.*?%\"\n            },\n            {\n               // Obviously these are neither keywords nor operators, but\n               // labelling them as such was the easiest way to get them\n               // to be colored distinctly from regular text\n               token : \"paren.keyword.operator\",\n               regex : \"[[({]\"\n            },\n            {\n               // Obviously these are neither keywords nor operators, but\n               // labelling them as such was the easiest way to get them\n               // to be colored distinctly from regular text\n               token : \"paren.keyword.operator\",\n               regex : \"[\\\\])}]\"\n            },\n            {\n               token : \"text\",\n               regex : \"\\\\s+\"\n            }\n         ],\n         \"qqstring\" : [\n            {\n               token : \"string\",\n               regex : '(?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?\"',\n               next : \"start\"\n            },\n            {\n               token : \"string\",\n               regex : '.+'\n            }\n         ],\n         \"qstring\" : [\n            {\n               token : \"string\",\n               regex : \"(?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?'\",\n               next : \"start\"\n            },\n            {\n               token : \"string\",\n               regex : '.+'\n            }\n         ]\n      };\n\n      var rdRules = new TexHighlightRules(\"comment\").getRules();\n\n      // Make all embedded TeX virtual-comment so they don't interfere with\n      // auto-indent.\n      for (var i = 0; i < rdRules[\"start\"].length; i++) {\n         rdRules[\"start\"][i].token += \".virtual-comment\";\n      }\n\n      this.addRules(rdRules, \"rd-\");\n      this.$rules[\"rd-start\"].unshift({\n          token: \"text\",\n          regex: \"^\",\n          next: \"start\"\n      });\n      this.$rules[\"rd-start\"].unshift({\n         token : \"keyword\",\n         regex : \"@(?!@)[^ ]*\"\n      });\n      this.$rules[\"rd-start\"].unshift({\n         token : \"comment\",\n         regex : \"@@\"\n      });\n      this.$rules[\"rd-start\"].push({\n         token : \"comment\",\n         regex : \"[^%\\\\\\\\[({\\\\])}]+\"\n      });\n   };\n\n   oop.inherits(RHighlightRules, TextHighlightRules);\n\n   exports.RHighlightRules = RHighlightRules;\n","/*\n * tex_highlight_rules.js\n *\n * Copyright (C) 2009-11 by RStudio, Inc.\n *\n * The Initial Developer of the Original Code is\n * Ajax.org B.V.\n * Portions created by the Initial Developer are Copyright (C) 2010\n * the Initial Developer. All Rights Reserved.\n *\n * Distributed under the BSD license:\n *\n * Copyright (c) 2010, Ajax.org B.V.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Ajax.org B.V. nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n *\n */\n\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar TexHighlightRules = function(textClass) {\n\n    if (!textClass)\n        textClass = \"text\";\n\n    // regexp must not have capturing parentheses. Use (?:) instead.\n    // regexps are ordered -> the first match is used\n\n    this.$rules = {\n        \"start\" : [\n            {\n                token : \"comment\",\n                regex : \"%.*$\"\n            }, {\n                token : textClass, // non-command\n                regex : \"\\\\\\\\[$&%#\\\\{\\\\}]\"\n            }, {\n                token : \"keyword\", // command\n                regex : \"\\\\\\\\(?:documentclass|usepackage|newcounter|setcounter|addtocounter|value|arabic|stepcounter|newenvironment|renewenvironment|ref|vref|eqref|pageref|label|cite[a-zA-Z]*|tag|begin|end|bibitem)\\\\b\",\n               next : \"nospell\"\n            }, {\n                token : \"keyword\", // command\n                regex : \"\\\\\\\\(?:[a-zA-Z0-9]+|[^a-zA-Z0-9])\"\n            }, {\n               // Obviously these are neither keywords nor operators, but\n               // labelling them as such was the easiest way to get them\n               // to be colored distinctly from regular text\n               token : \"paren.keyword.operator\",\n                regex : \"[[({]\"\n            }, {\n               // Obviously these are neither keywords nor operators, but\n               // labelling them as such was the easiest way to get them\n               // to be colored distinctly from regular text\n               token : \"paren.keyword.operator\",\n                regex : \"[\\\\])}]\"\n            }, {\n                token : textClass,\n                regex : \"\\\\s+\"\n            }\n        ],\n        // This mode is necessary to prevent spell checking, but to keep the\n        // same syntax highlighting behavior. The list of commands comes from\n        // Texlipse.\n        \"nospell\" : [\n           {\n               token : \"comment\",\n               regex : \"%.*$\",\n               next : \"start\"\n           }, {\n               token : \"nospell.\" + textClass, // non-command\n               regex : \"\\\\\\\\[$&%#\\\\{\\\\}]\"\n           }, {\n               token : \"keyword\", // command\n               regex : \"\\\\\\\\(?:documentclass|usepackage|newcounter|setcounter|addtocounter|value|arabic|stepcounter|newenvironment|renewenvironment|ref|vref|eqref|pageref|label|cite[a-zA-Z]*|tag|begin|end|bibitem)\\\\b\"\n           }, {\n               token : \"keyword\", // command\n               regex : \"\\\\\\\\(?:[a-zA-Z0-9]+|[^a-zA-Z0-9])\",\n               next : \"start\"\n           }, {\n               token : \"paren.keyword.operator\",\n               regex : \"[[({]\"\n           }, {\n               token : \"paren.keyword.operator\",\n               regex : \"[\\\\])]\"\n           }, {\n               token : \"paren.keyword.operator\",\n               regex : \"}\",\n               next : \"start\"\n           }, {\n               token : \"nospell.\" + textClass,\n               regex : \"\\\\s+\"\n           }, {\n               token : \"nospell.\" + textClass,\n               regex : \"\\\\w+\"\n           }\n        ]\n    };\n};\n\noop.inherits(TexHighlightRules, TextHighlightRules);\n\nexports.TexHighlightRules = TexHighlightRules;\n"],"names":["Range","require","MatchingBraceOutdent","this","checkOutdent","line","input","test","autoOutdent","doc","row","getLine","match","column","length","openBracePos","findMatchingBracket","indent","$getIndent","replace","call","prototype","exports","unicode","oop","TextMode","RHighlightRules","Mode","HighlightRules","$outdent","$behaviour","$defaultBehaviour","inherits","lineCommentStart","tokenRe","RegExp","wordChars","nonTokenRe","$id","snippetFileId","lang","TextHighlightRules","TexHighlightRules","keywords","arrayToMap","split","buildinConstants","$rules","token","regex","next","onMatch","value","rdRules","getRules","i","addRules","unshift","push","textClass"],"sourceRoot":""}