{"version":3,"file":"js/4800.0e3e5400.js","mappings":"2GAEA,IAAIA,EAAMC,EAAQ,OACdC,EAAeD,EAAAA,OAAAA,SACfE,EAAQF,EAAAA,OAAAA,EAERG,EAAWC,EAAQ,EAAW,WAAY,EAC9CL,EAAIM,SAASF,EAAUF,GAEvB,WACIK,KAAKC,aAAe,SAASC,EAASC,GAClC,IAAIC,EAAK,KACLC,EAAOH,EAAQI,QAAQH,GACvBI,EAAaF,EAAKG,OAAOJ,GAC7B,IAAmB,GAAfG,GAAwC,KAApBF,EAAKE,GAA7B,CAGA,IAAIE,EAAcJ,EAAKK,OACnBC,EAAST,EAAQU,YACjBC,EAAWV,EACXW,EAASX,EAEb,QAASA,EAAMQ,EAAQ,CACnBN,EAAOH,EAAQI,QAAQH,GACvB,IAAIY,EAAQV,EAAKG,OAAOJ,GAExB,IAAc,GAAVW,EAAJ,CAGA,GAAmB,KAAfV,EAAKU,GACL,MAEJD,EAASX,CALG,CAMhB,CAEA,GAAIW,EAASD,EAAU,CACnB,IAAIG,EAAYd,EAAQI,QAAQQ,GAAQJ,OACxC,OAAO,IAAId,EAAMiB,EAAUJ,EAAaK,EAAQE,EACpD,CAvBU,CAwBd,EAEAhB,KAAKiB,mBAAqB,SAASf,EAASgB,EAAWf,GACnD,IAAIgB,EAAQnB,KAAKoB,iBAAiBlB,EAASC,GAC3C,OAAIgB,IAGJA,EAAQnB,KAAKC,aAAaC,EAASC,GAC/BgB,QAAJ,EAEJ,EAGAnB,KAAKqB,cAAgB,SAASnB,EAASgB,EAAWf,GAC9C,IAAIE,EAAOH,EAAQI,QAAQH,GACvBmB,EAASjB,EAAKG,OAAO,MACrBe,EAAOrB,EAAQI,QAAQH,EAAM,GAC7BqB,EAAOtB,EAAQI,QAAQH,EAAM,GAC7BsB,EAAaD,EAAKhB,OAAO,MACzBkB,EAAaH,EAAKf,OAAO,MAE7B,IAAe,GAAXc,EAEA,OADApB,EAAQyB,YAAYxB,EAAM,IAAmB,GAAdsB,GAAmBA,EAAaC,EAAa,QAAU,GAC/E,GAIX,IAAmB,GAAfD,GACA,GAAIH,GAAUI,GAA8B,KAAhBrB,EAAKiB,IAAkC,KAAhBC,EAAKD,GAGpD,OAFApB,EAAQyB,YAAYxB,EAAM,GAAK,GAC/BD,EAAQyB,YAAYxB,EAAM,GAAK,GACxB,aAER,GAAIsB,GAAcH,GAA0B,KAAhBjB,EAAKiB,IAAkC,KAAhBE,EAAKF,KACb,GAA1CpB,EAAQI,QAAQH,EAAM,GAAGK,OAAO,MAGhC,OAFAN,EAAQyB,YAAYxB,EAAM,GAAK,QAC/BD,EAAQyB,YAAYxB,EAAM,GAAK,GACxB,GASf,OAJID,EAAQyB,YAAYxB,EAAM,IADZ,GAAdsB,GAAmBA,EAAaH,EACD,QAEA,GAE/BA,EAASI,EACF,QAEA,EACf,CAEH,EAAEE,KAAK/B,EAASgC,U,wBCzFjB,IAAIpC,EAAMC,EAAQ,OACdoC,EAAWpC,EAAAA,OAAAA,KACXqC,EAAuBrC,EAAAA,MAAAA,EACvBG,EAAWH,EAAAA,OAAAA,EACXsC,EAAgBtC,EAAAA,OAAAA,cAChBE,EAAQF,EAAAA,OAAAA,EACRuC,EAAuBvC,EAAAA,OAAAA,qBAEvBwC,EAAO,WACPlC,KAAKmC,eAAiBJ,EACtB/B,KAAKoC,aAAe,IAAIvC,EACxBG,KAAKqC,SAAW,IAAIJ,EACpBjC,KAAKsC,WAAatC,KAAKuC,iBAC3B,EACA9C,EAAIM,SAASmC,EAAMJ,GAEnB,WACI9B,KAAKwC,iBAAmB,KACxBxC,KAAKyC,aAAe,CAACC,MAAO,KAAMC,IAAK,MAEvC3C,KAAK4C,kBAAoB,SAASC,EAAOxC,EAAMyC,GAC3C,IAAIxB,EAAStB,KAAK+C,WAAW1C,GAEzB2C,EAAgBhD,KAAKiD,eAAeC,cAAc7C,EAAMwC,GACxDM,EAASH,EAAcG,OACvBC,EAAWJ,EAAcH,MAC7B,GAAI,iBAAiBQ,KAAKD,GACtB,OAAO9B,EACX,GAAI6B,EAAOzC,QAA4C,kBAAlCyC,EAAOA,EAAOzC,OAAS,GAAG4C,KAC3C,OAAOhC,EAECjB,EAAKkD,QAGjB,MAFI,wBAAwBF,KAAKhD,KAC7BiB,GAAUwB,GACPxB,CACX,EAEAtB,KAAKwD,aAAe,SAASX,EAAOxC,EAAMoD,GACtC,QAAIzD,KAAKqC,SAASmB,aAAanD,EAAMoD,KAGvB,OAAVA,GAA4B,SAAVA,MAGjB,OAAOJ,KAAKhD,EAIrB,EAEAL,KAAK0D,YAAc,SAASb,EAAOc,EAAKxD,GACpC,IAAIH,KAAKqC,SAASqB,YAAYC,EAAKxD,GAAnC,CAEA,IAAIyD,EAAWD,EAAIrD,QAAQH,GACvBoD,EAAQK,EAASL,MAAM,QACvBM,EAASD,EAASE,YAAY,KAAO,EACzC,IAAKP,IAAUpD,IAAQ0D,EAAQ,OAAO,EAE3BF,EAAIrD,QAAQH,EAAM,GAA7B,IACI4D,EAAa/D,KAAKgE,YAAYL,EAAK,CAACxD,IAAKA,EAAK0D,OAAQA,IAC1D,IAAKE,GAAcA,EAAWrB,MAAMvC,KAAOA,EAAK,OAAO,EAEvD0D,EAASN,EAAM,GAAG7C,OAClB,IAAIY,EAAStB,KAAK+C,WAAWY,EAAIrD,QAAQyD,EAAWrB,MAAMvC,MAC1DwD,EAAIM,QAAQ,IAAIrE,EAAMO,EAAM,EAAG,EAAGA,EAAM,EAAG0D,GAASvC,EAZ1C,CAad,EAEAtB,KAAKgE,YAAc,SAAS9D,EAASC,EAAK0D,QAC3BK,GAAP/D,IACAA,EAAMD,EAAQiE,UAAUC,MACV,iBAAPjE,IACP0D,EAAS1D,EAAI0D,OACb1D,EAAMA,EAAIA,KAGd,IAEIkE,EAFAC,EAAapE,EAAQqE,WAAWpE,EAAK0D,GACrCW,EAAW,gBAAiBC,EAAS,cAEzC,GAAKH,EAAL,CAEA,GAAIA,EAAWhB,MAAQkB,EAAU,CAC7B,IAAIE,EAAK,IAAI1C,EAAc9B,EAASC,EAAK0D,GACzCa,EAAGC,KAAOD,EAAGE,WACjB,KAAO,IAAIN,EAAWhB,MAAQmB,EAI1B,OAHIC,EAAK,IAAI1C,EAAc9B,EAASC,EAAK0D,GACzCa,EAAGC,KAAOD,EAAGG,YAEP,CAEV,MAAOR,EAAMK,EAAGC,OACZ,GAAIN,EAAIf,MAAQkB,GAAYH,EAAIf,MAAQmB,EACpC,MAER,GAAKJ,GAAOA,EAAIf,MAAQgB,EAAWhB,KAAnC,CAGA,IAAIwB,EAAMJ,EAAGK,wBACT5E,EAAMuE,EAAGM,qBACb,OAAO,IAAIpF,EAAMO,EAAK2E,EAAK3E,EAAK2E,EAAMT,EAAIY,MAAMvE,OAJtC,CAfA,CAoBd,EACAV,KAAKkF,IAAM,iBACd,EAAEtD,KAAKM,EAAKL,WAEb/B,EAAQoC,KAAOA,C,uBCrGf,IAAIzC,EAAMC,EAAQ,OACdyF,EAAqBzF,EAAAA,OAAAA,EAErBqC,EAAuB,WAIvB/B,KAAKoF,OAAS,CAAE1C,MACb,CAAE,CAAE2C,MAAO,gBACPC,MAAO,OACPC,KACC,CAAE,CAAEF,MAAO,gBAAiBC,MAAO,OAAQ/D,KAAM,OAC/C,CAAEiE,aAAc,mBAGrB,CAAEH,MAAO,iBACPC,MAAO,QAGT,CAAED,MAAO,mBACPC,MAAO,2CAIT,CAAED,MAAO,SACPC,MAAO,IACPC,KACC,CAAE,CAAEF,MAAO,SAAUC,MAAO,IAAK/D,KAAM,OACrC,CAAEiE,aAAc,YAGrB,CAAEH,MAAO,oBACPC,MAAO,sBAGT,CAAED,MAAO,6BACPC,MAAO,6BAGT,CAAED,MAAO,gBAAiBC,MAAO,KAAOG,QAAS,cACjD,CAAEJ,MAAO,gBAAiBC,MAAO,SAAOG,QAAS,sBACjD,CAAEJ,MAAO,gBAAiBC,MAAO,KAAOG,QAAS,QACjD,CAAEJ,MAAO,gBAAiBC,MAAO,MAAOG,QAAS,gBACjD,CAAEJ,MAAO,cAAiBC,MAAO,MAAOG,QAAS,cACjD,CAAEJ,MAAO,gBAAiBC,MAAO,IAAOG,QAAS,YACjD,CAAEJ,MAAO,gBAAiBC,MAAO,IAAOG,QAAS,eACjD,CAAEJ,MAAO,gBAAiBC,MAAO,IAAOG,QAAS,eACjD,CAAEJ,MAAO,mBAAoBC,MAAO,eAAgBG,QAAS,YAC7D,CAAEJ,MAAO,gBAAiBC,MAAO,IAAKG,QAAS,YAC/C,CAAEJ,MAAO,mBAAoBC,MAAO,cAAeG,QAAS,yBAC5D,CAAEJ,MAAO,UAAWC,MAAO,KAAMG,QAAS,eAC1C,CAAEJ,MAAO,mBACPC,MAAO,iBACPC,KACC,CAAE,CAAEG,QAAS,SACX,CAAEL,MAAO,mBACPC,MAAO,KACP/D,KAAM,SAGb,CAAE8D,MAAO,mBACPC,MAAO,qBAGT,CAAED,MAAO,CAAE,eAAgB,QACzBC,MAAO,+DAGT,CAAED,MAAO,cACPC,MAAO,6DAGT,CAAED,MAAO,qBACPC,MAAO,8DAIdtF,KAAK2F,gBACT,EAEAlG,EAAIM,SAASgC,EAAsBoD,GAEnCrF,EAAQ,EAAuBiC,C,wBCpF/B,IAAInC,EAAQF,EAAAA,OAAAA,EAERuC,EAAuB,WAAY,GAEvC,WAEIjC,KAAKwD,aAAe,SAASnD,EAAMoD,GAC/B,QAAM,QAAQJ,KAAKhD,IAGZ,SAASgD,KAAKI,EACzB,EAEAzD,KAAK0D,YAAc,SAASC,EAAKxD,GAC7B,IAAIE,EAAOsD,EAAIrD,QAAQH,GACnBoD,EAAQlD,EAAKkD,MAAM,YAEvB,IAAKA,EAAO,OAAO,EAEnB,IAAIM,EAASN,EAAM,GAAG7C,OAClBkF,EAAejC,EAAIkC,oBAAoB,CAAC1F,IAAKA,EAAK0D,OAAQA,IAE9D,IAAK+B,GAAgBA,EAAazF,KAAOA,EAAK,OAAO,EAErD,IAAImB,EAAStB,KAAK+C,WAAWY,EAAIrD,QAAQsF,EAAazF,MACtDwD,EAAIM,QAAQ,IAAIrE,EAAMO,EAAK,EAAGA,EAAK0D,EAAO,GAAIvC,EAClD,EAEAtB,KAAK+C,WAAa,SAAS1C,GACvB,OAAOA,EAAKkD,MAAM,QAAQ,EAC9B,CAEH,GAAE3B,KAAKK,EAAqBJ,WAE7B/B,EAAQmC,qBAAuBA,C","sources":["webpack://admin/./node_modules/ace-code/src/mode/folding/coffee.js","webpack://admin/./node_modules/ace-code/src/mode/logiql.js","webpack://admin/./node_modules/ace-code/src/mode/logiql_highlight_rules.js","webpack://admin/./node_modules/ace-code/src/mode/matching_brace_outdent.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    this.commentBlock = function(session, row) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        range = this.commentBlock(session, row);\n        if (range)\n            return range;\n    };\n\n    // must return \"\" if there's no fold, to enable caching\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n\n        // documentation comments\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar LogiQLHighlightRules = require(\"./logiql_highlight_rules\").LogiQLHighlightRules;\nvar FoldMode = require(\"./folding/coffee\").FoldMode;\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar Range = require(\"../range\").Range;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\n\nvar Mode = function() {\n    this.HighlightRules = LogiQLHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    this.lineCommentStart = \"//\";\n    this.blockComment = {start: \"/*\", end: \"*/\"};\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n        var endState = tokenizedLine.state;\n        if (/comment|string/.test(endState))  \n            return indent;\n        if (tokens.length && tokens[tokens.length - 1].type == \"comment.single\")\n            return indent;\n\n        var match = line.match();\n        if (/(-->|<--|<-|->|{)\\s*$/.test(line))\n            indent += tab;\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        if (this.$outdent.checkOutdent(line, input))\n            return true;\n\n        if (input !== \"\\n\" && input !== \"\\r\\n\")\n            return false;\n            \n        if (!/^\\s+/.test(line))\n            return false;\n\n        return true;\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        if (this.$outdent.autoOutdent(doc, row))\n            return;\n        var prevLine = doc.getLine(row);\n        var match = prevLine.match(/^\\s+/);\n        var column = prevLine.lastIndexOf(\".\") + 1;\n        if (!match || !row || !column) return 0;\n\n        var line = doc.getLine(row + 1);\n        var startRange = this.getMatching(doc, {row: row, column: column});\n        if (!startRange || startRange.start.row == row) return 0;\n\n        column = match[0].length;\n        var indent = this.$getIndent(doc.getLine(startRange.start.row));\n        doc.replace(new Range(row + 1, 0, row + 1, column), indent);\n    };\n\n    this.getMatching = function(session, row, column) {\n        if (row == undefined)\n            row = session.selection.lead;\n        if (typeof row == \"object\") {\n            column = row.column;\n            row = row.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        var KW_START = \"keyword.start\", KW_END = \"keyword.end\";\n        var tok;\n        if (!startToken)\n            return;\n        if (startToken.type == KW_START) {\n            var it = new TokenIterator(session, row, column);\n            it.step = it.stepForward;\n        } else if (startToken.type == KW_END) {\n            var it = new TokenIterator(session, row, column);\n            it.step = it.stepBackward;\n        } else\n            return;\n\n        while (tok = it.step()) {\n            if (tok.type == KW_START || tok.type == KW_END)\n                break;\n        }\n        if (!tok || tok.type == startToken.type)\n            return;\n\n        var col = it.getCurrentTokenColumn();\n        var row = it.getCurrentTokenRow();\n        return new Range(row, col, row, col + tok.value.length);\n    };\n    this.$id = \"ace/mode/logiql\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","/* THIS FILE WAS AUTOGENERATED FROM tool\\LogicBlox.tmbundle\\Syntaxes\\LogicBlox.tmLanguage (UUID: 59bf5022-e261-453f-b1cb-9f9fa0712413) */\n\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar LogiQLHighlightRules = function() {\n    // regexp must not have capturing parentheses. Use (?:) instead.\n    // regexps are ordered -> the first match is used\n\n    this.$rules = { start: \n       [ { token: 'comment.block',\n           regex: '/\\\\*',\n           push: \n            [ { token: 'comment.block', regex: '\\\\*/', next: 'pop' },\n              { defaultToken: 'comment.block' } ]\n           //A block comment.\n            },\n         { token: 'comment.single',\n           regex: '//.*'\n           //A single line comment.\n            },\n         { token: 'constant.numeric',\n           regex: '\\\\d+(?:\\\\.\\\\d+)?(?:[eE][+-]?\\\\d+)?[fd]?'\n           //An integer constant.\n           //Or a Real number.\n            },\n         { token: 'string',\n           regex: '\"',\n           push: \n            [ { token: 'string', regex: '\"', next: 'pop' },\n              { defaultToken: 'string' } ]\n           //Strings\n            },\n         { token: 'constant.language',\n           regex: '\\\\b(true|false)\\\\b'\n           //Boolean values.\n            },\n         { token: 'entity.name.type.logicblox',\n           regex: '`[a-zA-Z_:]+(\\\\d|\\\\a)*\\\\b'\n           //LogicBlox Symbol\n            },\n         { token: 'keyword.start', regex: '->',  comment: 'Constraint' },\n         { token: 'keyword.start', regex: '-->', comment: 'Level 1 Constraint'},\n         { token: 'keyword.start', regex: '<-',  comment: 'Rule' },\n         { token: 'keyword.start', regex: '<--', comment: 'Level 1 Rule' },\n         { token: 'keyword.end',   regex: '\\\\.', comment: 'Terminator' },\n         { token: 'keyword.other', regex: '!',   comment: 'Negation' },\n         { token: 'keyword.other', regex: ',',   comment: 'Conjunction' },\n         { token: 'keyword.other', regex: ';',   comment: 'Disjunction' },\n         { token: 'keyword.operator', regex: '<=|>=|!=|<|>', comment: 'Equality'},\n         { token: 'keyword.other', regex: '@', comment: 'Equality' },\n         { token: 'keyword.operator', regex: '\\\\+|-|\\\\*|/', comment: 'Arithmetic operations'},\n         { token: 'keyword', regex: '::', comment: 'Colon colon' },\n         { token: 'support.function',\n           regex: '\\\\b(agg\\\\s*<<)',\n           push: \n            [ { include: '$self' },\n              { token: 'support.function',\n                regex: '>>',\n                next: 'pop' } ]\n            //Aggregations\n            },\n         { token: 'storage.modifier',\n           regex: '\\\\b(lang:[\\\\w:]*)'\n           //All the lang system predicates\n            },\n         { token: [ 'storage.type', 'text' ],\n           regex: '(export|sealed|clauses|block|alias|alias_all)(\\\\s*\\\\()(?=`)'\n           //Module keywords\n            },\n         { token: 'entity.name',\n           regex: '[a-zA-Z_][a-zA-Z_0-9:]*(@prev|@init|@final)?(?=(\\\\(|\\\\[))'\n           //A predicate name.\n            },\n         { token: 'variable.parameter',\n           regex: '([a-zA-Z][a-zA-Z_0-9]*|_)\\\\s*(?=(,|\\\\.|<-|->|\\\\)|\\\\]|=))'\n           //A variable to a functional predicate.\n            } ] };\n    \n    this.normalizeRules();\n};\n\noop.inherits(LogiQLHighlightRules, TextHighlightRules);\n\nexports.LogiQLHighlightRules = LogiQLHighlightRules;\n","\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n"],"names":["oop","require","BaseFoldMode","Range","FoldMode","exports","inherits","this","commentBlock","session","row","re","line","getLine","startLevel","search","startColumn","length","maxRow","getLength","startRow","endRow","level","endColumn","getFoldWidgetRange","foldStyle","range","indentationBlock","getFoldWidget","indent","next","prev","prevIndent","nextIndent","foldWidgets","call","prototype","TextMode","LogiQLHighlightRules","TokenIterator","MatchingBraceOutdent","Mode","HighlightRules","foldingRules","$outdent","$behaviour","$defaultBehaviour","lineCommentStart","blockComment","start","end","getNextLineIndent","state","tab","$getIndent","tokenizedLine","getTokenizer","getLineTokens","tokens","endState","test","type","match","checkOutdent","input","autoOutdent","doc","prevLine","column","lastIndexOf","startRange","getMatching","replace","undefined","selection","lead","tok","startToken","getTokenAt","KW_START","KW_END","it","step","stepForward","stepBackward","col","getCurrentTokenColumn","getCurrentTokenRow","value","$id","TextHighlightRules","$rules","token","regex","push","defaultToken","comment","include","normalizeRules","openBracePos","findMatchingBracket"],"sourceRoot":""}