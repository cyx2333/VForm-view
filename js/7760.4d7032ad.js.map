{"version":3,"file":"js/7760.4d7032ad.js","mappings":"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","sources":["webpack://admin/./node_modules/ace-code/src/mode/folding/ruby.js","webpack://admin/./node_modules/ace-code/src/mode/matching_brace_outdent.js","webpack://admin/./node_modules/ace-code/src/mode/ruby.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\n\nvar FoldMode = exports.FoldMode = function () {\n};\n\noop.inherits(FoldMode, BaseFoldMode);\n\n(function () {\n    this.indentKeywords = {\n        \"class\": 1,\n        \"def\": 1,\n        \"module\": 1,\n        \"do\": 1,\n        \"unless\": 1,\n        \"if\": 1,\n        \"while\": 1,\n        \"for\": 1,\n        \"until\": 1,\n        \"begin\": 1,\n        \"else\": 0,\n        \"elsif\": 0,\n        \"rescue\": 0,\n        \"ensure\": 0,\n        \"when\": 0,\n        \"end\": -1,\n        \"case\": 1,\n        \"=begin\": 1,\n        \"=end\": -1\n    };\n\n    this.foldingStartMarker = /(?:\\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\\b|({\\s*$)|(=begin)/;\n    this.foldingStopMarker = /(=end(?=$|\\s.*$))|(^\\s*})|\\b(end)\\b/;\n\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n\n        if (isStart && !isEnd) {\n            var match = line.match(this.foldingStartMarker);\n            if (match[1]) {\n                if (match[1] == \"if\" || match[1] == \"else\" || match[1] == \"while\" || match[1] == \"until\" || match[1] == \"unless\") {\n                    if (match[1] == \"else\" && /^\\s*else\\s*$/.test(line) === false) {\n                        return;\n                    }\n                    if (/^\\s*(?:if|else|while|until|unless)\\s*/.test(line) === false) {\n                        return;\n                    }\n                }\n\n                if (match[1] == \"when\") {\n                    if (/\\sthen\\s/.test(line) === true) {\n                        return;\n                    }\n                }\n                if (session.getTokenAt(row, match.index + 2).type === \"keyword\")\n                    return \"start\";\n            } else if (match[3]) {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return \"start\";\n            } else {\n                return \"start\";\n            }\n        }\n        if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd)\n            return \"\";\n\n        var match = line.match(this.foldingStopMarker);\n        if (match[3] === \"end\") {\n            if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                return \"end\";\n        } else if (match[1]) {\n            if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                return \"end\";\n        } else\n            return \"end\";\n    };\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1] || match[3])\n                return this.rubyBlock(session, row, match.index + 2);\n\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[3] === \"end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n\n            if (match[1] === \"=end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n\n    this.rubyBlock = function (session, row, column, tokenRange) {\n        var stream = new TokenIterator(session, row, column);\n\n        var token = stream.getCurrentToken();\n        if (!token || (token.type != \"keyword\" && token.type != \"comment.multiline\"))\n            return;\n\n        var val = token.value;\n        var line = session.getLine(row);\n        switch (token.value) {\n            case \"if\":\n            case \"unless\":\n            case \"while\":\n            case \"until\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = this.indentKeywords[val];\n                break;\n            case \"when\":\n                if (/\\sthen\\s/.test(line)) {\n                    return;\n                }\n            case \"elsif\":\n            case \"rescue\":\n            case \"ensure\":\n                var dir = 1;\n                break;\n            case \"else\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = 1;\n                break;\n            default:\n                var dir = this.indentKeywords[val];\n                break;\n        }\n\n        var stack = [val];\n        if (!dir)\n            return;\n\n        var startColumn = dir === -1 ? session.getLine(row - 1).length : session.getLine(row).length;\n        var startRow = row;\n        var ranges = [];\n        ranges.push(stream.getCurrentTokenRange());\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        if (token.type == \"comment.multiline\") {\n            while (token = stream.step()) {\n                if (token.type !== \"comment.multiline\")\n                    continue;\n                if (dir == 1) {\n                    startColumn = 6;\n                    if (token.value == \"=end\") {\n                        break;\n                    }\n                } else {\n                    if (token.value == \"=begin\") {\n                        break;\n                    }\n                }\n            }\n        } else {\n            while (token = stream.step()) {\n                var ignore = false;\n                if (token.type !== \"keyword\")\n                    continue;\n                var level = dir * this.indentKeywords[token.value];\n                line = session.getLine(stream.getCurrentTokenRow());\n                switch (token.value) {\n                    case \"do\":\n                        for (var i = stream.$tokenIndex - 1; i >= 0; i--) {\n                            var prevToken = stream.$rowTokens[i];\n                            if (prevToken && (prevToken.value == \"while\" || prevToken.value == \"until\" || prevToken.value == \"for\")) {\n                                level = 0;\n                                break;\n                            }\n                        }\n                        break;\n                    case \"else\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                        if (!checkToken.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"if\":\n                    case \"unless\":\n                    case \"while\":\n                    case \"until\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                        if (!checkToken.test(line)) {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"when\":\n                        if (/\\sthen\\s/.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                }\n\n                if (level > 0) {\n                    stack.unshift(token.value);\n                } else if (level <= 0 && ignore === false) {\n                    stack.shift();\n                    if (!stack.length) {\n                        if ((val == \"while\" || val == \"until\" || val == \"for\") && token.value != \"do\") {\n                            break;\n                        }\n                        if (token.value == \"do\" && dir == -1 && level != 0)\n                            break;\n                        if (token.value != \"do\")\n                            break;\n                    }\n\n                    if (level === 0) {\n                        stack.unshift(token.value);\n                    }\n                }\n            }\n        }\n\n        if (!token)\n            return null;\n\n        if (tokenRange) {\n            ranges.push(stream.getCurrentTokenRange());\n            return ranges;\n        }\n\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1) {\n            if (token.type === \"comment.multiline\") {\n                var endColumn = 6;\n            } else {\n                var endColumn = session.getLine(row).length;\n            }\n            return new Range(row, endColumn, startRow - 1, startColumn);\n        } else\n            return new Range(startRow, startColumn, row - 1, session.getLine(row - 1).length);\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar RubyHighlightRules = require(\"./ruby_highlight_rules\").RubyHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar Range = require(\"../range\").Range;\nvar FoldMode = require(\"./folding/ruby\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = RubyHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n    this.foldingRules = new FoldMode();\n    this.indentKeywords = this.foldingRules.indentKeywords;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n\n    this.lineCommentStart = \"#\";\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n\n        if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n            var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n            var startingConditional = line.match(/^\\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\\s*/);\n            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n                indent += tab;\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return /^\\s+(end|else|rescue|ensure)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, session, row) {\n        var line = session.getLine(row);\n        if (/}/.test(line))\n            return this.$outdent.autoOutdent(session, row);\n        var indent = this.$getIndent(line);\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine);\n        var tab = session.getTabString();\n        if (prevIndent.length <= indent.length) {\n            if (indent.slice(-tab.length) == tab)\n                session.remove(new Range(row, indent.length - tab.length, row, indent.length));\n        }\n    };\n\n    this.getMatching = function(session, row, column) {\n        if (row == undefined) {\n            var pos = session.selection.lead;\n            column = pos.column;\n            row = pos.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        if (startToken && startToken.value in this.indentKeywords)\n            return this.foldingRules.rubyBlock(session, row, column, true);\n    };\n\n    this.$id = \"ace/mode/ruby\";\n    this.snippetFileId = \"ace/snippets/ruby\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n"],"names":["require","oop","BaseFoldMode","Range","TokenIterator","FoldMode","exports","inherits","this","indentKeywords","foldingStartMarker","foldingStopMarker","getFoldWidget","session","foldStyle","row","line","getLine","isStart","test","isEnd","match","getTokenAt","index","type","getFoldWidgetRange","doc","exec","rubyBlock","openingBracketBlock","closingBracketBlock","length","column","tokenRange","stream","token","getCurrentToken","val","value","checkToken","RegExp","dir","stack","startColumn","startRow","ranges","push","getCurrentTokenRange","step","stepBackward","stepForward","ignore","level","getCurrentTokenRow","i","$tokenIndex","prevToken","$rowTokens","unshift","shift","endColumn","call","prototype","MatchingBraceOutdent","checkOutdent","input","autoOutdent","openBracePos","findMatchingBracket","indent","$getIndent","replace","TextMode","RubyHighlightRules","Mode","HighlightRules","$outdent","$behaviour","$defaultBehaviour","foldingRules","lineCommentStart","getNextLineIndent","state","tab","tokenizedLine","getTokenizer","getLineTokens","tokens","startingClassOrMethod","startingDoBlock","startingConditional","prevLine","prevIndent","getTabString","slice","remove","getMatching","undefined","pos","selection","lead","startToken","$id","snippetFileId"],"sourceRoot":""}