{"version":3,"file":"js/4507.a6d35cab.js","mappings":"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","sources":["webpack://admin/./node_modules/ace-code/src/mode/elixir.js","webpack://admin/./node_modules/ace-code/src/mode/elixir_highlight_rules.js","webpack://admin/./node_modules/ace-code/src/mode/folding/coffee.js","webpack://admin/./node_modules/ace-code/src/mode/html_elixir.js","webpack://admin/./node_modules/ace-code/src/mode/html_elixir_highlight_rules.js"],"sourcesContent":["/*\n  THIS FILE WAS AUTOGENERATED BY mode.tmpl.js\n*/\n\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar ElixirHighlightRules = require(\"./elixir_highlight_rules\").ElixirHighlightRules;\nvar FoldMode = require(\"./folding/coffee\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = ElixirHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    this.lineCommentStart = \"#\";\n    // this.blockComment = {start: \"\"/*\"\", end: \"\"*/\"\"};\n    // Extra logic goes here.\n    this.$id = \"ace/mode/elixir\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","/* This file was autogenerated from https://raw.githubusercontent.com/elixir-lang/elixir-tmbundle/master/Syntaxes/Elixir.tmLanguage (uuid: ) */\n/****************************************************************************************\n * IT MIGHT NOT BE PERFECT ...But it's a good start from an existing *.tmlanguage file. *\n * fileTypes                                                                            *\n ****************************************************************************************/\n\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar ElixirHighlightRules = function() {\n    // regexp must not have capturing parentheses. Use (?:) instead.\n    // regexps are ordered -> the first match is used\n\n    this.$rules = { start: \n       [ { token: \n            [ 'meta.module.elixir',\n              'keyword.control.module.elixir',\n              'meta.module.elixir',\n              'entity.name.type.module.elixir' ],\n           regex: '^(\\\\s*)(defmodule)(\\\\s+)((?:[A-Z]\\\\w*\\\\s*\\\\.\\\\s*)*[A-Z]\\\\w*)' },\n         { token: 'comment.documentation.heredoc',\n           regex: '@(?:module|type)?doc (?:~[a-z])?\"\"\"',\n           push: \n            [ { token: 'comment.documentation.heredoc',\n                regex: '\\\\s*\"\"\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'comment.documentation.heredoc' } ],\n           comment: '@doc with heredocs is treated as documentation' },\n         { token: 'comment.documentation.heredoc',\n           regex: '@(?:module|type)?doc ~[A-Z]\"\"\"',\n           push: \n            [ { token: 'comment.documentation.heredoc',\n                regex: '\\\\s*\"\"\"',\n                next: 'pop' },\n              { defaultToken: 'comment.documentation.heredoc' } ],\n           comment: '@doc with heredocs is treated as documentation' },\n         { token: 'comment.documentation.heredoc',\n           regex: '@(?:module|type)?doc (?:~[a-z])?\\'\\'\\'',\n           push: \n            [ { token: 'comment.documentation.heredoc',\n                regex: '\\\\s*\\'\\'\\'',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'comment.documentation.heredoc' } ],\n           comment: '@doc with heredocs is treated as documentation' },\n         { token: 'comment.documentation.heredoc',\n           regex: '@(?:module|type)?doc ~[A-Z]\\'\\'\\'',\n           push: \n            [ { token: 'comment.documentation.heredoc',\n                regex: '\\\\s*\\'\\'\\'',\n                next: 'pop' },\n              { defaultToken: 'comment.documentation.heredoc' } ],\n           comment: '@doc with heredocs is treated as documentation' },\n         { token: 'comment.documentation.false',\n           regex: '@(?:module|type)?doc false',\n           comment: '@doc false is treated as documentation' },\n         { token: 'comment.documentation.string',\n           regex: '@(?:module|type)?doc \"',\n           push: \n            [ { token: 'comment.documentation.string',\n                regex: '\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'comment.documentation.string' } ],\n           comment: '@doc with string is treated as documentation' },\n         { token: 'keyword.control.elixir',\n           regex: '\\\\b(?:do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?<!\\\\.)\\\\b(do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])' },\n         { token: 'keyword.operator.elixir',\n           regex: '\\\\b(?:and|not|or|when|xor|in|inlist|inbits)\\\\b',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?<!\\\\.)\\\\b(and|not|or|when|xor|in|inlist|inbits)\\\\b',\n           comment: ' as above, just doesn\\'t need a \\'end\\' and does a logic operation' },\n         { token: 'constant.language.elixir',\n           regex: '\\\\b(?:nil|true|false)\\\\b(?![?!])' },\n         { token: 'variable.language.elixir',\n           regex: '\\\\b__(?:CALLER|ENV|MODULE|DIR)__\\\\b(?![?!])' },\n         { token: \n            [ 'punctuation.definition.variable.elixir',\n              'variable.other.readwrite.module.elixir' ],\n           regex: '(@)([a-zA-Z_]\\\\w*)' },\n         { token: \n            [ 'punctuation.definition.variable.elixir',\n              'variable.other.anonymous.elixir' ],\n           regex: '(&)(\\\\d*)' },\n         { token: 'variable.other.constant.elixir',\n           regex: '\\\\b[A-Z]\\\\w*\\\\b' },\n         { token: 'constant.numeric.elixir',\n           regex: '\\\\b(?:0x[\\\\da-fA-F](?:_?[\\\\da-fA-F])*|\\\\d(?:_?\\\\d)*(?:\\\\.(?![^[:space:][:digit:]])(?:_?\\\\d)*)?(?:[eE][-+]?\\\\d(?:_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '\\\\b(0x\\\\h(?>_?\\\\h)*|\\\\d(?>_?\\\\d)*(\\\\.(?![^[:space:][:digit:]])(?>_?\\\\d)*)?([eE][-+]?\\\\d(?>_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b' },\n         { token: 'punctuation.definition.constant.elixir',\n           regex: ':\\'',\n           push: \n            [ { token: 'punctuation.definition.constant.elixir',\n                regex: '\\'',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'constant.other.symbol.single-quoted.elixir' } ] },\n         { token: 'punctuation.definition.constant.elixir',\n           regex: ':\"',\n           push: \n            [ { token: 'punctuation.definition.constant.elixir',\n                regex: '\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'constant.other.symbol.double-quoted.elixir' } ] },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '(?:\\'\\'\\')',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?>\\'\\'\\')',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '^\\\\s*\\'\\'\\'',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'support.function.variable.quoted.single.heredoc.elixir' } ],\n           comment: 'Single-quoted heredocs' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '\\'',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\'',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'support.function.variable.quoted.single.elixir' } ],\n           comment: 'single quoted string (allows for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '(?:\"\"\")',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?>\"\"\")',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '^\\\\s*\"\"\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.quoted.double.heredoc.elixir' } ],\n           comment: 'Double-quoted heredocs' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '\"',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.quoted.double.elixir' } ],\n           comment: 'double quoted string (allows for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z](?:\"\"\")',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '~[a-z](?>\"\"\")',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '^\\\\s*\"\"\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.quoted.double.heredoc.elixir' } ],\n           comment: 'Double-quoted heredocs sigils' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z]\\\\{',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\}[a-z]*',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.interpolated.elixir' } ],\n           comment: 'sigil (allow for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z]\\\\[',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\][a-z]*',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.interpolated.elixir' } ],\n           comment: 'sigil (allow for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z]\\\\<',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\>[a-z]*',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.interpolated.elixir' } ],\n           comment: 'sigil (allow for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z]\\\\(',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\)[a-z]*',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.interpolated.elixir' } ],\n           comment: 'sigil (allow for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z][^\\\\w]',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '[^\\\\w][a-z]*',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.interpolated.elixir' } ],\n           comment: 'sigil (allow for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z](?:\"\"\")',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '~[A-Z](?>\"\"\")',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '^\\\\s*\"\"\"',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'Double-quoted heredocs sigils' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z]\\\\{',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\}[a-z]*',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'sigil (without interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z]\\\\[',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\][a-z]*',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'sigil (without interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z]\\\\<',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\>[a-z]*',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'sigil (without interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z]\\\\(',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\)[a-z]*',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'sigil (without interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z][^\\\\w]',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '[^\\\\w][a-z]*',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'sigil (without interpolation)' },\n         { token: ['punctuation.definition.constant.elixir', 'constant.other.symbol.elixir'],\n           regex: '(:)([a-zA-Z_][\\\\w@]*(?:[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(?:\\\\^\\\\^)?)',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?<!:)(:)(?>[a-zA-Z_][\\\\w@]*(?>[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(\\\\^\\\\^)?)',\n           comment: 'symbols' },\n         { token: 'punctuation.definition.constant.elixir',\n           regex: '(?:[a-zA-Z_][\\\\w@]*(?:[?!])?):(?!:)',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?>[a-zA-Z_][\\\\w@]*(?>[?!])?)(:)(?!:)',\n           comment: 'symbols' },\n         { token: \n            [ 'punctuation.definition.comment.elixir',\n              'comment.line.number-sign.elixir' ],\n           regex: '(#)(.*)' },\n         { token: 'constant.numeric.elixir',\n           regex: '\\\\?(?:\\\\\\\\(?:x[\\\\da-fA-F]{1,2}(?![\\\\da-fA-F])\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?<!\\\\w)\\\\?(\\\\\\\\(x\\\\h{1,2}(?!\\\\h)\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n           comment: '\\n\\t\\t\\tmatches questionmark-letters.\\n\\n\\t\\t\\texamples (1st alternation = hex):\\n\\t\\t\\t?\\\\x1     ?\\\\x61\\n\\n\\t\\t\\texamples (2rd alternation = escaped):\\n\\t\\t\\t?\\\\n      ?\\\\b\\n\\n\\t\\t\\texamples (3rd alternation = normal):\\n\\t\\t\\t?a       ?A       ?0 \\n\\t\\t\\t?*       ?\"       ?( \\n\\t\\t\\t?.       ?#\\n\\t\\t\\t\\n\\t\\t\\tthe negative lookbehind prevents against matching\\n\\t\\t\\tp(42.tainted?)\\n\\t\\t\\t' },\n        /* { token: 'punctuation.separator.variable.elixir',\n           regex: '(?<=\\\\{|do|\\\\{\\\\s|do\\\\s)\\\\|',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?<=\\\\{|do|\\\\{\\\\s|do\\\\s)(\\\\|)',\n           push: \n            [ { token: 'punctuation.separator.variable.elixir',\n                regex: '\\\\|',\n                next: 'pop' },\n              { token: 'variable.other.block.elixir',\n                regex: '[_a-zA-Z][_a-zA-Z0-9]*' },\n              { token: 'punctuation.separator.variable.elixir', regex: ',' } ] },*/\n         { token: 'keyword.operator.assignment.augmented.elixir',\n           regex: '\\\\+=|\\\\-=|\\\\|\\\\|=|~=|&&=' },\n         { token: 'keyword.operator.comparison.elixir',\n           regex: '===?|!==?|<=?|>=?' },\n         { token: 'keyword.operator.bitwise.elixir',\n           regex: '\\\\|{3}|&{3}|\\\\^{3}|<{3}|>{3}|~{3}' },\n         { token: 'keyword.operator.logical.elixir',\n           regex: '!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b',\n           originalRegex: '(?<=[ \\\\t])!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b' },\n         { token: 'keyword.operator.arithmetic.elixir',\n           regex: '\\\\*|\\\\+|\\\\-|/' },\n         { token: 'keyword.operator.other.elixir',\n           regex: '\\\\||\\\\+\\\\+|\\\\-\\\\-|\\\\*\\\\*|\\\\\\\\\\\\\\\\|\\\\<\\\\-|\\\\<\\\\>|\\\\<\\\\<|\\\\>\\\\>|\\\\:\\\\:|\\\\.\\\\.|\\\\|>|~|=>' },\n         { token: 'keyword.operator.assignment.elixir', regex: '=' },\n         { token: 'punctuation.separator.other.elixir', regex: ':' },\n         { token: 'punctuation.separator.statement.elixir',\n           regex: '\\\\;' },\n         { token: 'punctuation.separator.object.elixir', regex: ',' },\n         { token: 'punctuation.separator.method.elixir', regex: '\\\\.' },\n         { token: 'punctuation.section.scope.elixir', regex: '\\\\{|\\\\}' },\n         { token: 'punctuation.section.array.elixir', regex: '\\\\[|\\\\]' },\n         { token: 'punctuation.section.function.elixir',\n           regex: '\\\\(|\\\\)' } ],\n      '#escaped_char': \n       [ { token: 'constant.character.escape.elixir',\n           regex: '\\\\\\\\(?:x[\\\\da-fA-F]{1,2}|.)' } ],\n      '#interpolated_elixir': \n       [ { token: \n            [ 'source.elixir.embedded.source',\n              'source.elixir.embedded.source.empty' ],\n           regex: '(#\\\\{)(\\\\})' },\n         { todo: \n            { token: 'punctuation.section.embedded.elixir',\n              regex: '#\\\\{',\n              push: \n               [ { token: 'punctuation.section.embedded.elixir',\n                   regex: '\\\\}',\n                   next: 'pop' },\n                 { include: '#nest_curly_and_self' },\n                 { include: '$self' },\n                 { defaultToken: 'source.elixir.embedded.source' } ] } } ],\n      '#nest_curly_and_self': \n       [ { token: 'punctuation.section.scope.elixir',\n           regex: '\\\\{',\n           push: \n            [ { token: 'punctuation.section.scope.elixir',\n                regex: '\\\\}',\n                next: 'pop' },\n              { include: '#nest_curly_and_self' } ] },\n         { include: '$self' } ],\n      '#regex_sub': \n       [ { include: '#interpolated_elixir' },\n         { include: '#escaped_char' },\n         { token: \n            [ 'punctuation.definition.arbitrary-repitition.elixir',\n              'string.regexp.arbitrary-repitition.elixir',\n              'string.regexp.arbitrary-repitition.elixir',\n              'punctuation.definition.arbitrary-repitition.elixir' ],\n           regex: '(\\\\{)(\\\\d+)((?:,\\\\d+)?)(\\\\})' },\n         { token: 'punctuation.definition.character-class.elixir',\n           regex: '\\\\[(?:\\\\^?\\\\])?',\n           push: \n            [ { token: 'punctuation.definition.character-class.elixir',\n                regex: '\\\\]',\n                next: 'pop' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.regexp.character-class.elixir' } ] },\n         { token: 'punctuation.definition.group.elixir',\n           regex: '\\\\(',\n           push: \n            [ { token: 'punctuation.definition.group.elixir',\n                regex: '\\\\)',\n                next: 'pop' },\n              { include: '#regex_sub' },\n              { defaultToken: 'string.regexp.group.elixir' } ] },\n         { token: \n            [ 'punctuation.definition.comment.elixir',\n              'comment.line.number-sign.elixir' ],\n           regex: '(?:^|\\\\s)(#)(\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x00-\\\\x7F]]*$)',\n           originalRegex: '(?<=^|\\\\s)(#)\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x{00}-\\\\x{7F}]]*$',\n           comment: 'We are restrictive in what we allow to go after the comment character to avoid false positives, since the availability of comments depend on regexp flags.' } ] };\n    \n    this.normalizeRules();\n};\n\nElixirHighlightRules.metaData = { comment: 'Textmate bundle for Elixir Programming Language.',\n      fileTypes: [ 'ex', 'exs' ],\n      firstLineMatch: '^#!/.*\\\\belixir',\n      foldingStartMarker: '(after|else|catch|rescue|\\\\-\\\\>|\\\\{|\\\\[|do)\\\\s*$',\n      foldingStopMarker: '^\\\\s*((\\\\}|\\\\]|after|else|catch|rescue)\\\\s*$|end\\\\b)',\n      keyEquivalent: '^~E',\n      name: 'Elixir',\n      scopeName: 'source.elixir' };\n\n\noop.inherits(ElixirHighlightRules, TextHighlightRules);\n\nexports.ElixirHighlightRules = ElixirHighlightRules;\n","\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    this.commentBlock = function(session, row) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        range = this.commentBlock(session, row);\n        if (range)\n            return range;\n    };\n\n    // must return \"\" if there's no fold, to enable caching\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n\n        // documentation comments\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar HtmlElixirHighlightRules = require(\"./html_elixir_highlight_rules\").HtmlElixirHighlightRules;\nvar HtmlMode = require(\"./html\").Mode;\nvar JavaScriptMode = require(\"./javascript\").Mode;\nvar CssMode = require(\"./css\").Mode;\nvar ElixirMode = require(\"./elixir\").Mode;\n\nvar Mode = function() {\n    HtmlMode.call(this);   \n    this.HighlightRules = HtmlElixirHighlightRules;\n    this.createModeDelegates({\n        \"js-\": JavaScriptMode,\n        \"css-\": CssMode,\n        \"elixir-\": ElixirMode\n    });\n};\noop.inherits(Mode, HtmlMode);\n\n(function() {\n\n    this.$id = \"ace/mode/html_elixir\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\n    var oop = require(\"../lib/oop\");\n    var HtmlHighlightRules = require(\"./html_highlight_rules\").HtmlHighlightRules;\n    var ElixirHighlightRules = require(\"./elixir_highlight_rules\").ElixirHighlightRules;\n\n    var HtmlElixirHighlightRules = function() {\n        HtmlHighlightRules.call(this);\n\n        var startRules = [\n            {\n                regex: \"<%%|%%>\",\n                token: \"constant.language.escape\"\n            }, {\n                token : \"comment.start.eex\",\n                regex : \"<%#\",\n                push  : [{\n                    token : \"comment.end.eex\",\n                    regex: \"%>\",\n                    next: \"pop\",\n                    defaultToken:\"comment\"\n                }]\n            }, {\n                token : \"support.elixir_tag\",\n                regex : \"<%+(?!>)[-=]?\",\n                push  : \"elixir-start\"\n            }\n        ];\n\n        var endRules = [\n            {\n                token : \"support.elixir_tag\",\n                regex : \"%>\",\n                next  : \"pop\"\n            }, {\n                token: \"comment\",\n                regex: \"#(?:[^%]|%[^>])*\"\n            }\n        ];\n\n        for (var key in this.$rules)\n            this.$rules[key].unshift.apply(this.$rules[key], startRules);\n\n        this.embedRules(ElixirHighlightRules, \"elixir-\", endRules, [\"start\"]);\n\n        this.normalizeRules();\n    };\n\n\n    oop.inherits(HtmlElixirHighlightRules, HtmlHighlightRules);\n\n    exports.HtmlElixirHighlightRules = HtmlElixirHighlightRules;\n"],"names":["oop","require","TextMode","ElixirHighlightRules","FoldMode","Mode","this","HighlightRules","foldingRules","$behaviour","$defaultBehaviour","inherits","lineCommentStart","$id","call","prototype","exports","TextHighlightRules","$rules","start","token","regex","push","next","include","defaultToken","comment","TODO","originalRegex","todo","normalizeRules","metaData","fileTypes","firstLineMatch","foldingStartMarker","foldingStopMarker","keyEquivalent","name","scopeName","BaseFoldMode","Range","commentBlock","session","row","re","line","getLine","startLevel","search","startColumn","length","maxRow","getLength","startRow","endRow","level","endColumn","getFoldWidgetRange","foldStyle","range","indentationBlock","getFoldWidget","indent","prev","prevIndent","nextIndent","foldWidgets","HtmlElixirHighlightRules","HtmlMode","JavaScriptMode","CssMode","ElixirMode","createModeDelegates","HtmlHighlightRules","startRules","endRules","key","unshift","apply","embedRules"],"sourceRoot":""}