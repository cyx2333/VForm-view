{"version":3,"file":"js/4684.1a5ff08f.js","mappings":"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","sources":["webpack://admin/./node_modules/ace-code/src/mode/coffee.js","webpack://admin/./node_modules/ace-code/src/mode/coffee_highlight_rules.js","webpack://admin/./node_modules/ace-code/src/mode/folding/coffee.js","webpack://admin/./node_modules/ace-code/src/mode/matching_brace_outdent.js"],"sourcesContent":["\"use strict\";\n\nvar Rules = require(\"./coffee_highlight_rules\").CoffeeHighlightRules;\nvar Outdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar FoldMode = require(\"./folding/coffee\").FoldMode;\nvar Range = require(\"../range\").Range;\nvar TextMode = require(\"./text\").Mode;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\nvar oop = require(\"../lib/oop\");\n\nfunction Mode() {\n    this.HighlightRules = Rules;\n    this.$outdent = new Outdent();\n    this.foldingRules = new FoldMode();\n}\n\noop.inherits(Mode, TextMode);\n\n(function() {\n    \n    /*:\n      [({[=:]        # Opening parentheses or brackets\n     |[-=]>          # OR single or double arrow\n     |\\b(?:          # OR one of these words:\n       else          #    else\n      |try           # OR try\n      |(?:swi|ca)tch # OR catch, optionally followed by:\n        (?:\\s*[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*)?  # a variable\n      |finally       # OR finally\n     ))\\s*$          # all as the last thing on a line (allowing trailing space)\n    |                # ---- OR ---- :\n    ^\\s*             # a line starting with optional space\n    (else\\b\\s*)?     # followed by an optional \"else\"\n    (?:              # followed by one of the following:\n       if            #    if\n      |for           # OR for\n      |while         # OR while\n      |loop          # OR loop\n    )\\b              #    (as a word)\n    (?!.*\\bthen\\b)   # ... but NOT followed by \"then\" on the line\n    */\n    var indenter = /(?:[({[=:]|[-=]>|\\b(?:else|try|(?:swi|ca)tch(?:\\s+[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*)?|finally))\\s*$|^\\s*(else\\b\\s*)?(?:if|for|while|loop)\\b(?!.*\\bthen\\b)/;\n    \n    this.lineCommentStart = \"#\";\n    this.blockComment = {start: \"###\", end: \"###\"};\n    \n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;\n    \n        if (!(tokens.length && tokens[tokens.length - 1].type === 'comment') &&\n            state === 'start' && indenter.test(line))\n            indent += tab;\n        return indent;\n    };\n    \n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n    \n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n    \n    this.createWorker = function(session) {\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/coffee_worker\", \"Worker\");\n        worker.attachToDocument(session.getDocument());\n        \n        worker.on(\"annotate\", function(e) {\n            session.setAnnotations(e.data);\n        });\n        \n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n        \n        return worker;\n    };\n\n    this.$id = \"ace/mode/coffee\";\n    this.snippetFileId = \"ace/snippets/coffee\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\n    var oop = require(\"../lib/oop\");\n    var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n    oop.inherits(CoffeeHighlightRules, TextHighlightRules);\n\n    function CoffeeHighlightRules() {\n        var identifier = \"[$A-Za-z_\\\\x7f-\\\\uffff][$\\\\w\\\\x7f-\\\\uffff]*\";\n\n        var keywords = (\n            \"this|throw|then|try|typeof|super|switch|return|break|by|continue|\" +\n            \"catch|class|in|instanceof|is|isnt|if|else|extends|for|own|\" +\n            \"finally|function|while|when|new|no|not|delete|debugger|do|loop|of|off|\" +\n            \"or|on|unless|until|and|yes|yield|export|import|default\"\n        );\n\n        var langConstant = (\n            \"true|false|null|undefined|NaN|Infinity\"\n        );\n\n        var illegal = (\n            \"case|const|function|var|void|with|enum|implements|\" +\n            \"interface|let|package|private|protected|public|static\"\n        );\n\n        var supportClass = (\n            \"Array|Boolean|Date|Function|Number|Object|RegExp|ReferenceError|String|\" +\n            \"Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|\" +\n            \"SyntaxError|TypeError|URIError|\"  +\n            \"ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|\" +\n            \"Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray\"\n        );\n\n        var supportFunction = (\n            \"Math|JSON|isNaN|isFinite|parseInt|parseFloat|encodeURI|\" +\n            \"encodeURIComponent|decodeURI|decodeURIComponent|String|\"\n        );\n\n        var variableLanguage = (\n            \"window|arguments|prototype|document\"\n        );\n\n        var keywordMapper = this.createKeywordMapper({\n            \"keyword\": keywords,\n            \"constant.language\": langConstant,\n            \"invalid.illegal\": illegal,\n            \"language.support.class\": supportClass,\n            \"language.support.function\": supportFunction,\n            \"variable.language\": variableLanguage\n        }, \"identifier\");\n\n        var functionRule = {\n            token: [\"paren.lparen\", \"variable.parameter\", \"paren.rparen\", \"text\", \"storage.type\"],\n            regex: /(?:(\\()((?:\"[^\")]*?\"|'[^')]*?'|\\/[^\\/)]*?\\/|[^()\"'\\/])*?)(\\))(\\s*))?([\\-=]>)/.source\n        };\n\n        var stringEscape = /\\\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.)/;\n\n        this.$rules = {\n            start : [\n                {\n                    token : \"constant.numeric\",\n                    regex : \"(?:0x[\\\\da-fA-F]+|(?:\\\\d+(?:\\\\.\\\\d+)?|\\\\.\\\\d+)(?:[eE][+-]?\\\\d+)?)\"\n                }, {\n                    stateName: \"qdoc\",\n                    token : \"string\", regex : \"'''\", next : [\n                        {token : \"string\", regex : \"'''\", next : \"start\"},\n                        {token : \"constant.language.escape\", regex : stringEscape},\n                        {defaultToken: \"string\"}\n                    ]\n                }, {\n                    stateName: \"qqdoc\",\n                    token : \"string\",\n                    regex : '\"\"\"',\n                    next : [\n                        {token : \"string\", regex : '\"\"\"', next : \"start\"},\n                        {token : \"paren.string\", regex : '#{', push : \"start\"},\n                        {token : \"constant.language.escape\", regex : stringEscape},\n                        {defaultToken: \"string\"}\n                    ]\n                }, {\n                    stateName: \"qstring\",\n                    token : \"string\", regex : \"'\", next : [\n                        {token : \"string\", regex : \"'\", next : \"start\"},\n                        {token : \"constant.language.escape\", regex : stringEscape},\n                        {defaultToken: \"string\"}\n                    ]\n                }, {\n                    stateName: \"qqstring\",\n                    token : \"string.start\", regex : '\"', next : [\n                        {token : \"string.end\", regex : '\"', next : \"start\"},\n                        {token : \"paren.string\", regex : '#{', push : \"start\"},\n                        {token : \"constant.language.escape\", regex : stringEscape},\n                        {defaultToken: \"string\"}\n                    ]\n                }, {\n                    stateName: \"js\",\n                    token : \"string\", regex : \"`\", next : [\n                        {token : \"string\", regex : \"`\", next : \"start\"},\n                        {token : \"constant.language.escape\", regex : stringEscape},\n                        {defaultToken: \"string\"}\n                    ]\n                }, {\n                    regex: \"[{}]\", onMatch: function(val, state, stack) {\n                        this.next = \"\";\n                        if (val == \"{\" && stack.length) {\n                            stack.unshift(\"start\", state);\n                            return \"paren\";\n                        }\n                        if (val == \"}\" && stack.length) {\n                            stack.shift();\n                            this.next = stack.shift() || \"\";\n                            if (this.next.indexOf(\"string\") != -1)\n                                return \"paren.string\";\n                        }\n                        return \"paren\";\n                    }\n                }, {\n                    token : \"string.regex\",\n                    regex : \"///\",\n                    next : \"heregex\"\n                }, {\n                    token : \"string.regex\",\n                    regex : /(?:\\/(?![\\s=])[^[\\/\\n\\\\]*(?:(?:\\\\[\\s\\S]|\\[[^\\]\\n\\\\]*(?:\\\\[\\s\\S][^\\]\\n\\\\]*)*])[^[\\/\\n\\\\]*)*\\/)(?:[imgy]{0,4})(?!\\w)/\n                }, {\n                    token : \"comment\",\n                    regex : \"###(?!#)\",\n                    next : \"comment\"\n                }, {\n                    token : \"comment\",\n                    regex : \"#.*\"\n                }, {\n                    token : [\"punctuation.operator\", \"text\", \"identifier\"],\n                    regex : \"(\\\\.)(\\\\s*)(\" + illegal + \")\"\n                }, {\n                    token : \"punctuation.operator\",\n                    regex : \"\\\\.{1,3}\"\n                }, {\n                    //class A extends B\n                    token : [\"keyword\", \"text\", \"language.support.class\",\n                     \"text\", \"keyword\", \"text\", \"language.support.class\"],\n                    regex : \"(class)(\\\\s+)(\" + identifier + \")(?:(\\\\s+)(extends)(\\\\s+)(\" + identifier + \"))?\"\n                }, {\n                    //play = (...) ->\n                    token : [\"entity.name.function\", \"text\", \"keyword.operator\", \"text\"].concat(functionRule.token),\n                    regex : \"(\" + identifier + \")(\\\\s*)([=:])(\\\\s*)\" + functionRule.regex\n                }, \n                functionRule, \n                {\n                    token : \"variable\",\n                    regex : \"@(?:\" + identifier + \")?\"\n                }, {\n                    token: keywordMapper,\n                    regex : identifier\n                }, {\n                    token : \"punctuation.operator\",\n                    regex : \"\\\\,|\\\\.\"\n                }, {\n                    token : \"storage.type\",\n                    regex : \"[\\\\-=]>\"\n                }, {\n                    token : \"keyword.operator\",\n                    regex : \"(?:[-+*/%<>&|^!?=]=|>>>=?|\\\\-\\\\-|\\\\+\\\\+|::|&&=|\\\\|\\\\|=|<<=|>>=|\\\\?\\\\.|\\\\.{2,3}|[!*+-=><])\"\n                }, {\n                    token : \"paren.lparen\",\n                    regex : \"[({[]\"\n                }, {\n                    token : \"paren.rparen\",\n                    regex : \"[\\\\]})]\"\n                }, {\n                    token : \"text\",\n                    regex : \"\\\\s+\"\n                }],\n\n\n            heregex : [{\n                token : \"string.regex\",\n                regex : '.*?///[imgy]{0,4}',\n                next : \"start\"\n            }, {\n                token : \"comment.regex\",\n                regex : \"\\\\s+(?:#.*)?\"\n            }, {\n                token : \"string.regex\",\n                regex : \"\\\\S+\"\n            }],\n\n            comment : [{\n                token : \"comment\",\n                regex : '###',\n                next : \"start\"\n            }, {\n                defaultToken : \"comment\"\n            }]\n        };\n        this.normalizeRules();\n    }\n\n    exports.CoffeeHighlightRules = CoffeeHighlightRules;\n","\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    this.commentBlock = function(session, row) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        range = this.commentBlock(session, row);\n        if (range)\n            return range;\n    };\n\n    // must return \"\" if there's no fold, to enable caching\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n\n        // documentation comments\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n"],"names":["Rules","require","Outdent","FoldMode","TextMode","WorkerClient","oop","Mode","this","HighlightRules","$outdent","foldingRules","inherits","indenter","lineCommentStart","blockComment","start","end","getNextLineIndent","state","line","tab","indent","$getIndent","tokens","getTokenizer","getLineTokens","length","type","test","checkOutdent","input","autoOutdent","doc","row","createWorker","session","worker","attachToDocument","getDocument","on","e","setAnnotations","data","clearAnnotations","$id","snippetFileId","call","prototype","exports","TextHighlightRules","CoffeeHighlightRules","identifier","keywords","langConstant","illegal","supportClass","supportFunction","variableLanguage","keywordMapper","createKeywordMapper","functionRule","token","regex","source","stringEscape","$rules","stateName","next","defaultToken","push","onMatch","val","stack","unshift","shift","indexOf","concat","heregex","comment","normalizeRules","BaseFoldMode","Range","commentBlock","re","getLine","startLevel","search","startColumn","maxRow","getLength","startRow","endRow","level","endColumn","getFoldWidgetRange","foldStyle","range","indentationBlock","getFoldWidget","prev","prevIndent","nextIndent","foldWidgets","MatchingBraceOutdent","match","column","openBracePos","findMatchingBracket","replace"],"sourceRoot":""}