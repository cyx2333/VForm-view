{"version":3,"file":"js/4131.8eda90bf.js","mappings":"2GAEA,IAAIA,EAAMC,EAAQ,OACdC,EAAeD,EAAAA,OAAAA,SACfE,EAAQF,EAAAA,OAAAA,EAERG,EAAWC,EAAQ,EAAW,WAAY,EAC9CL,EAAIM,SAASF,EAAUF,GAEvB,WACIK,KAAKC,aAAe,SAASC,EAASC,GAClC,IAAIC,EAAK,KACLC,EAAOH,EAAQI,QAAQH,GACvBI,EAAaF,EAAKG,OAAOJ,GAC7B,IAAmB,GAAfG,GAAwC,KAApBF,EAAKE,GAA7B,CAGA,IAAIE,EAAcJ,EAAKK,OACnBC,EAAST,EAAQU,YACjBC,EAAWV,EACXW,EAASX,EAEb,QAASA,EAAMQ,EAAQ,CACnBN,EAAOH,EAAQI,QAAQH,GACvB,IAAIY,EAAQV,EAAKG,OAAOJ,GAExB,IAAc,GAAVW,EAAJ,CAGA,GAAmB,KAAfV,EAAKU,GACL,MAEJD,EAASX,CALG,CAMhB,CAEA,GAAIW,EAASD,EAAU,CACnB,IAAIG,EAAYd,EAAQI,QAAQQ,GAAQJ,OACxC,OAAO,IAAId,EAAMiB,EAAUJ,EAAaK,EAAQE,EACpD,CAvBU,CAwBd,EAEAhB,KAAKiB,mBAAqB,SAASf,EAASgB,EAAWf,GACnD,IAAIgB,EAAQnB,KAAKoB,iBAAiBlB,EAASC,GAC3C,OAAIgB,IAGJA,EAAQnB,KAAKC,aAAaC,EAASC,GAC/BgB,QAAJ,EAEJ,EAGAnB,KAAKqB,cAAgB,SAASnB,EAASgB,EAAWf,GAC9C,IAAIE,EAAOH,EAAQI,QAAQH,GACvBmB,EAASjB,EAAKG,OAAO,MACrBe,EAAOrB,EAAQI,QAAQH,EAAM,GAC7BqB,EAAOtB,EAAQI,QAAQH,EAAM,GAC7BsB,EAAaD,EAAKhB,OAAO,MACzBkB,EAAaH,EAAKf,OAAO,MAE7B,IAAe,GAAXc,EAEA,OADApB,EAAQyB,YAAYxB,EAAM,IAAmB,GAAdsB,GAAmBA,EAAaC,EAAa,QAAU,GAC/E,GAIX,IAAmB,GAAfD,GACA,GAAIH,GAAUI,GAA8B,KAAhBrB,EAAKiB,IAAkC,KAAhBC,EAAKD,GAGpD,OAFApB,EAAQyB,YAAYxB,EAAM,GAAK,GAC/BD,EAAQyB,YAAYxB,EAAM,GAAK,GACxB,aAER,GAAIsB,GAAcH,GAA0B,KAAhBjB,EAAKiB,IAAkC,KAAhBE,EAAKF,KACb,GAA1CpB,EAAQI,QAAQH,EAAM,GAAGK,OAAO,MAGhC,OAFAN,EAAQyB,YAAYxB,EAAM,GAAK,QAC/BD,EAAQyB,YAAYxB,EAAM,GAAK,GACxB,GASf,OAJID,EAAQyB,YAAYxB,EAAM,IADZ,GAAdsB,GAAmBA,EAAaH,EACD,QAEA,GAE/BA,EAASI,EACF,QAEA,EACf,CAEH,EAAEE,KAAK/B,EAASgC,U,wBCzFjB,IAAIpC,EAAMC,EAAQ,OACdoC,EAAiBpC,EAAAA,OAAAA,EACjBE,EAAQF,EAAAA,OAAAA,EAERG,EAAWC,EAAQ,EAAW,WAAY,EAC9CL,EAAIM,SAASF,EAAUiC,GAEvB,WACI9B,KAAKiB,mBAAqB,SAASf,EAASgB,EAAWf,GACnD,IAAIC,EAAK,KACLC,EAAOH,EAAQI,QAAQH,GACvBI,EAAaF,EAAKG,OAAOJ,GACzB2B,EAAqC,MAArB1B,EAAKE,GACrByB,EAAkC,MAArB3B,EAAKE,GAEtB,IAAmB,GAAfA,EAAJ,CAGA,IAAIE,EAAcJ,EAAKK,OACnBC,EAAST,EAAQU,YACjBC,EAAWV,EACXW,EAASX,EAGb,GAAI4B,EAAe,CACf,IAAIZ,EAAQnB,KAAKC,aAAaC,EAASC,GACvC,GAAIgB,EACA,OAAOA,CAEf,MAAO,GAAIa,EAAY,CACfb,EAAQnB,KAAKoB,iBAAiBlB,EAASC,GAC3C,GAAIgB,EACA,OAAOA,CAEf,MACI,QAAShB,EAAMQ,EAAQ,CACfN,EAAOH,EAAQI,QAAQH,GAA3B,IACIY,EAAQV,EAAKG,OAAOJ,GAExB,IAAc,GAAVW,EAAJ,CAGA,GAAIA,GAASR,GAAmC,MAArBF,EAAKE,GAAqB,CACjD,IAAI0B,EAAQ/B,EAAQgC,WAAW/B,EAAK,GACpC,IAAK8B,GAAwB,WAAfA,EAAME,KAChB,KACR,CAEArB,EAASX,CARG,CAShB,CAGJ,GAAIW,EAASD,EAAU,CACnB,IAAIG,EAAYd,EAAQI,QAAQQ,GAAQJ,OACxC,OAAO,IAAId,EAAMiB,EAAUJ,EAAaK,EAAQE,EACpD,CAvCU,CAwCd,EAGAhB,KAAKqB,cAAgB,SAASnB,EAASgB,EAAWf,GAC9C,IAAIE,EAAOH,EAAQI,QAAQH,GACvBmB,EAASjB,EAAKG,OAAO,MACrBe,EAAOrB,EAAQI,QAAQH,EAAM,GAC7BqB,EAAOtB,EAAQI,QAAQH,EAAM,GAC7BsB,EAAaD,EAAKhB,OAAO,MACzBkB,EAAaH,EAAKf,OAAO,MAEzB4B,EAAsC,MAAjB/B,EAAKiB,GAE9B,IAAe,GAAXA,EAEA,OADApB,EAAQyB,YAAYxB,EAAM,IAAmB,GAAdsB,GAAmBA,EAAaC,EAAa,QAAU,GAC/E,GAIX,IAAmB,GAAfD,GACA,GAAIH,GAAUI,GAA8B,KAAhBrB,EAAKiB,IAAkC,KAAhBC,EAAKD,GAGpD,OAFApB,EAAQyB,YAAYxB,EAAM,GAAK,GAC/BD,EAAQyB,YAAYxB,EAAM,GAAK,GACxB,aAER,GAAIsB,GAAcH,GAA0B,KAAhBjB,EAAKiB,IAAkC,KAAhBE,EAAKF,KACb,GAA1CpB,EAAQI,QAAQH,EAAM,GAAGK,OAAO,MAGhC,OAFAN,EAAQyB,YAAYxB,EAAM,GAAK,QAC/BD,EAAQyB,YAAYxB,EAAM,GAAK,GACxB,GAcf,OARID,EAAQyB,YAAYxB,EAAM,IADZ,GAAdsB,GAAmBA,EAAaH,IAGX,GAAdG,GAAqBA,GAAcH,GAAUc,EAFrB,QAKA,GAG/Bd,EAASI,EACF,QAEA,EACf,CAEH,EAAEE,KAAK/B,EAASgC,U,wBCzGjB,IAAIjC,EAAQF,EAAAA,OAAAA,EAER2C,EAAuB,WAAY,GAEvC,WAEIrC,KAAKsC,aAAe,SAASjC,EAAMkC,GAC/B,QAAM,QAAQC,KAAKnC,IAGZ,SAASmC,KAAKD,EACzB,EAEAvC,KAAKyC,YAAc,SAASC,EAAKvC,GAC7B,IAAIE,EAAOqC,EAAIpC,QAAQH,GACnBwC,EAAQtC,EAAKsC,MAAM,YAEvB,IAAKA,EAAO,OAAO,EAEnB,IAAIC,EAASD,EAAM,GAAGjC,OAClBmC,EAAeH,EAAII,oBAAoB,CAAC3C,IAAKA,EAAKyC,OAAQA,IAE9D,IAAKC,GAAgBA,EAAa1C,KAAOA,EAAK,OAAO,EAErD,IAAImB,EAAStB,KAAK+C,WAAWL,EAAIpC,QAAQuC,EAAa1C,MACtDuC,EAAIM,QAAQ,IAAIpD,EAAMO,EAAK,EAAGA,EAAKyC,EAAO,GAAItB,EAClD,EAEAtB,KAAK+C,WAAa,SAAS1C,GACvB,OAAOA,EAAKsC,MAAM,QAAQ,EAC9B,CAEH,GAAEf,KAAKS,EAAqBR,WAE7B/B,EAAQuC,qBAAuBA,C,uBClC/B,IAAI5C,EAAMC,EAAQ,OACduD,EAAWvD,EAAAA,OAAAA,KACXwD,EAAqBxD,EAAAA,MAAAA,EACrB2C,EAAuB3C,EAAAA,OAAAA,qBACvBG,EAAWH,EAAAA,OAAAA,EACXyD,EAAezD,EAAAA,OAAAA,aAEf0D,EAAO,WACPpD,KAAKqD,eAAiBH,EACtBlD,KAAKsD,SAAW,IAAIjB,EACpBrC,KAAKuD,aAAe,IAAI1D,EACxBG,KAAKwD,WAAaxD,KAAKyD,iBAC3B,EACAhE,EAAIM,SAASqD,EAAMH,GAEnB,WAEIjD,KAAK0D,iBAAmB,CAAC,KAEzB1D,KAAK2D,kBAAoB,SAASC,EAAOvD,EAAMwD,GAC3C,IAAIvC,EAAStB,KAAK+C,WAAW1C,GAE7B,GAAa,SAATuD,EAAkB,CAClB,IAAIjB,EAAQtC,EAAKsC,MAAM,mBACnBA,IACArB,GAAUuC,EAElB,CAEA,OAAOvC,CACX,EAEAtB,KAAKsC,aAAe,SAASsB,EAAOvD,EAAMkC,GACtC,OAAOvC,KAAKsD,SAAShB,aAAajC,EAAMkC,EAC5C,EAEAvC,KAAKyC,YAAc,SAASmB,EAAOlB,EAAKvC,GACpCH,KAAKsD,SAASb,YAAYC,EAAKvC,EACnC,EAEAH,KAAK8D,aAAe,SAAS5D,GACzB,IAAI6D,EAAS,IAAIZ,EAAa,CAAC,OAAQ,uBAAwB,cAW/D,OAVAY,EAAOC,iBAAiB9D,EAAQ+D,eAEhCF,EAAOG,GAAG,YAAY,SAASC,GAC3BjE,EAAQkE,eAAeD,EAAQE,KACnC,IAEAN,EAAOG,GAAG,aAAa,WACnBhE,EAAQoE,kBACZ,IAEOP,CACX,EAGA/D,KAAKuE,IAAM,eACd,EAAE3C,KAAKwB,EAAKvB,WAEb/B,EAAQsD,KAAOA,C,uBC7DF1D,EAAA,OAEb,IAAID,EAAMC,EAAQ,OACd8E,EAAqB9E,EAAAA,OAAAA,EAErBwD,EAAqB,WAIrBlD,KAAKyE,OAAS,CACV,MAAU,CACN,CACIxC,MAAQ,UACRyC,MAAQ,QACT,CACCzC,MAAQ,cACRyC,MAAQ,6BACR,CACAzC,MAAQ,cACRyC,MAAQ,qBACT,CACCzC,MAAO,WACPyC,MAAO,cACR,CACCzC,MAAO,oBACPyC,MAAO,wBACR,CACCzC,MAAO,CAAC,WAAY,WACpByC,MAAO,+BACT,CACEzC,MAAO,CAAC,WAAY,WACpByC,MAAO,8BACR,CACCzC,MAAQ,mBACRyC,MAAQ,eACT,CACCzC,MAAQ,mBACRyC,MAAQ,gBACT,CACCzC,MAAQ,SACRyC,MAAQ,sCACT,CACCzC,MAAQ,SACRyC,MAAQ,8BACRC,QAAS,SAASC,EAAKhB,EAAOiB,EAAOxE,GACjCA,EAAOA,EAAK2C,QAAQ,OAAQ,IAC5B,IAAI1B,EAAS,4BAA4BwD,KAAKzE,GAAM,GAC/C2C,QAAQ,SAAU,IAAItC,OACvBqE,EAAuBC,SAAS,cAAcF,KAAKzE,IAevD,OAbI0E,GACAzD,GAAUyD,EAAuB,EACjC/E,KAAKuB,KAAO,YAEZvB,KAAKuB,KAAO,cAEXsD,EAAMnE,QAIPmE,EAAM,GAAK7E,KAAKuB,KAChBsD,EAAM,GAAKvD,IAJXuD,EAAMI,KAAKjF,KAAKuB,MAChBsD,EAAMI,KAAK3D,IAKRtB,KAAKiC,KAChB,EACAV,KAAO,YACR,CACCU,MAAQ,SACRyC,MAAQ,sCACT,CACCzC,MAAQ,mBACRyC,MAAQ,2EACT,CACCzC,MAAQ,mBACRyC,MAAQ,+CACT,CACCzC,MAAQ,4BACRyC,MAAQ,qDACT,CACCzC,MAAQ,eACRyC,MAAQ,SACT,CACCzC,MAAQ,eACRyC,MAAQ,WACT,CACCzC,MAAQ,OACRyC,MAAQ,qBAGhB,YAAgB,CACZ,CACIzC,MAAQ,SACRyC,MAAQ,QACT,CACCzC,MAAQ,SACRyC,MAAQ,MACRC,QAAS,SAASC,EAAKhB,EAAOiB,GAC1B,IAAIK,EAAYL,EAAM,GAWtB,OATIK,GAAaN,EAAIlE,QACjBV,KAAKuB,KAAO,QACZsD,EAAMM,QACNN,EAAMM,UAGNN,EAAM,GAAKD,EAAIlE,OAAS,EACxBV,KAAKuB,KAAOsD,EAAM,GAAK,YAEpB7E,KAAKiC,KAChB,EACAV,KAAO,YACR,CACC6D,aAAe,WAGvB,SAAa,CACT,CACInD,MAAQ,SACRyC,MAAQ,QACT,CACCzC,MAAQ,SACRyC,MAAQ,MACRC,QAAS,SAASC,EAAKhB,EAAOiB,GAC1B,IAAIK,EAAYL,EAAM,GAStB,OAPIK,GAAaN,EAAIlE,QACjBV,KAAKuB,KAAO,QACZsD,EAAMQ,OAAO,IAGbrF,KAAKuB,KAAO,WAETvB,KAAKiC,KAChB,EACAV,KAAO,YACR,CACCU,MAAQ,SACRyC,MAAQ,QAGpB1E,KAAKsF,gBAET,EAEA7F,EAAIM,SAASmD,EAAoBsB,GAEjC1E,EAAQ,EAAqBoD,C","sources":["webpack://admin/./node_modules/ace-code/src/mode/folding/coffee.js","webpack://admin/./node_modules/ace-code/src/mode/folding/yaml.js","webpack://admin/./node_modules/ace-code/src/mode/matching_brace_outdent.js","webpack://admin/./node_modules/ace-code/src/mode/yaml.js","webpack://admin/./node_modules/ace-code/src/mode/yaml_highlight_rules.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    this.commentBlock = function(session, row) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        range = this.commentBlock(session, row);\n        if (range)\n            return range;\n    };\n\n    // must return \"\" if there's no fold, to enable caching\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n\n        // documentation comments\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar CoffeeFoldMode = require(\"./coffee\").FoldMode;\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, CoffeeFoldMode);\n\n(function() {\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        var isCommentFold = line[startLevel] === \"#\";\n        var isDashFold = line[startLevel] === \"-\";\n        \n        if (startLevel == -1)\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        // Comment folding\n        if (isCommentFold) {\n            var range = this.commentBlock(session, row);\n            if (range)\n                return range;\n        // Indentation folding (used for indentations that start with a '-').\n        } else if (isDashFold) {\n            var range = this.indentationBlock(session, row);\n            if (range)\n                return range;\n        // List folding (used for indentations that don't start with a '-')..\n        } else {\n            while (++row < maxRow) {\n                var line = session.getLine(row);\n                var level = line.search(re);\n\n                if (level == -1)\n                    continue;\n\n                if (level <= startLevel && line[startLevel] !== '-') {\n                    var token = session.getTokenAt(row, 0);\n                    if (!token || token.type !== \"string\")\n                        break;\n                }\n\n                endRow = row;\n            }\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    // must return \"\" if there's no fold, to enable caching\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        var lineStartsWithDash = line[indent] === '-';\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n\n        // documentation comments\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        // Indentation fold\n        if (prevIndent!= -1 && prevIndent < indent) {\n            session.foldWidgets[row - 1] = \"start\";\n        // Fold non-indented list\n        } else if (prevIndent!= -1 &&  (prevIndent == indent && lineStartsWithDash)) {\n            session.foldWidgets[row - 1] = \"start\";\n        } else {\n            session.foldWidgets[row - 1] = \"\";\n        }\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar YamlHighlightRules = require(\"./yaml_highlight_rules\").YamlHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar FoldMode = require(\"./folding/yaml\").FoldMode;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\n\nvar Mode = function() {\n    this.HighlightRules = YamlHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.foldingRules = new FoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n    this.lineCommentStart = [\"#\"];\n    \n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            if (match) {\n                indent += tab;\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n\n    this.createWorker = function(session) {\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/yaml_worker\", \"YamlWorker\");\n        worker.attachToDocument(session.getDocument());\n\n        worker.on(\"annotate\", function(results) {\n            session.setAnnotations(results.data);\n        });\n\n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n\n        return worker;\n    };\n\n\n    this.$id = \"ace/mode/yaml\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar YamlHighlightRules = function() {\n\n    // regexp must not have capturing parentheses. Use (?:) instead.\n    // regexps are ordered -> the first match is used\n    this.$rules = {\n        \"start\" : [\n            {\n                token : \"comment\",\n                regex : \"#.*$\"\n            }, {\n                token : \"list.markup\",\n                regex : /^(?:-{3}|\\.{3})\\s*(?=#|$)/\n            },  {\n                token : \"list.markup\",\n                regex : /^\\s*[\\-?](?:$|\\s)/\n            }, {\n                token: \"constant\",\n                regex: \"!![\\\\w//]+\"\n            }, {\n                token: \"constant.language\",\n                regex: \"[&\\\\*][a-zA-Z0-9-_]+\"\n            }, {\n                token: [\"meta.tag\", \"keyword\"],\n                regex: /^(\\s*\\w[^\\s:]*?)(:(?=\\s|$))/\n            },{\n                token: [\"meta.tag\", \"keyword\"],\n                regex: /(\\w[^\\s:]*?)(\\s*:(?=\\s|$))/\n            }, {\n                token : \"keyword.operator\",\n                regex : \"<<\\\\w*:\\\\w*\"\n            }, {\n                token : \"keyword.operator\",\n                regex : \"-\\\\s*(?=[{])\"\n            }, {\n                token : \"string\", // single line\n                regex : '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n            }, {\n                token : \"string\", // multi line string start\n                regex : /[|>][-+\\d]*(?:$|\\s+(?:$|#))/,\n                onMatch: function(val, state, stack, line) {\n                    line = line.replace(/ #.*/, \"\");\n                    var indent = /^ *((:\\s*)?-(\\s*[^|>])?)?/.exec(line)[0]\n                        .replace(/\\S\\s*$/, \"\").length;\n                    var indentationIndicator = parseInt(/\\d+[\\s+-]*$/.exec(line));\n                    \n                    if (indentationIndicator) {\n                        indent += indentationIndicator - 1;\n                        this.next = \"mlString\";\n                    } else {\n                        this.next = \"mlStringPre\";\n                    }\n                    if (!stack.length) {\n                        stack.push(this.next);\n                        stack.push(indent);\n                    } else {\n                        stack[0] = this.next;\n                        stack[1] = indent;\n                    }\n                    return this.token;\n                },\n                next : \"mlString\"\n            }, {\n                token : \"string\", // single quoted string\n                regex : \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n            }, {\n                token : \"constant.numeric\", // float\n                regex : /(\\b|[+\\-\\.])[\\d_]+(?:(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)(?=[^\\d-\\w]|$)$/\n            }, {\n                token : \"constant.numeric\", // other number\n                regex : /[+\\-]?\\.inf\\b|NaN\\b|0x[\\dA-Fa-f_]+|0b[10_]+/\n            }, {\n                token : \"constant.language.boolean\",\n                regex : \"\\\\b(?:true|false|TRUE|FALSE|True|False|yes|no)\\\\b\"\n            }, {\n                token : \"paren.lparen\",\n                regex : \"[[({]\"\n            }, {\n                token : \"paren.rparen\",\n                regex : \"[\\\\])}]\"\n            }, {\n                token : \"text\",\n                regex : /[^\\s,:\\[\\]\\{\\}]+/\n            }\n        ],\n        \"mlStringPre\" : [\n            {\n                token : \"indent\",\n                regex : /^ *$/\n            }, {\n                token : \"indent\",\n                regex : /^ */,\n                onMatch: function(val, state, stack) {\n                    var curIndent = stack[1];\n\n                    if (curIndent >= val.length) {\n                        this.next = \"start\";\n                        stack.shift();\n                        stack.shift();\n                    }\n                    else {\n                        stack[1] = val.length - 1;\n                        this.next = stack[0] = \"mlString\";\n                    }\n                    return this.token;\n                },\n                next : \"mlString\"\n            }, {\n                defaultToken : \"string\"\n            }\n        ],\n        \"mlString\" : [\n            {\n                token : \"indent\",\n                regex : /^ *$/\n            }, {\n                token : \"indent\",\n                regex : /^ */,\n                onMatch: function(val, state, stack) {\n                    var curIndent = stack[1];\n\n                    if (curIndent >= val.length) {\n                        this.next = \"start\";\n                        stack.splice(0);\n                    }\n                    else {\n                        this.next = \"mlString\";\n                    }\n                    return this.token;\n                },\n                next : \"mlString\"\n            }, {\n                token : \"string\",\n                regex : '.+'\n            }\n        ]};\n    this.normalizeRules();\n\n};\n\noop.inherits(YamlHighlightRules, TextHighlightRules);\n\nexports.YamlHighlightRules = YamlHighlightRules;\n"],"names":["oop","require","BaseFoldMode","Range","FoldMode","exports","inherits","this","commentBlock","session","row","re","line","getLine","startLevel","search","startColumn","length","maxRow","getLength","startRow","endRow","level","endColumn","getFoldWidgetRange","foldStyle","range","indentationBlock","getFoldWidget","indent","next","prev","prevIndent","nextIndent","foldWidgets","call","prototype","CoffeeFoldMode","isCommentFold","isDashFold","token","getTokenAt","type","lineStartsWithDash","MatchingBraceOutdent","checkOutdent","input","test","autoOutdent","doc","match","column","openBracePos","findMatchingBracket","$getIndent","replace","TextMode","YamlHighlightRules","WorkerClient","Mode","HighlightRules","$outdent","foldingRules","$behaviour","$defaultBehaviour","lineCommentStart","getNextLineIndent","state","tab","createWorker","worker","attachToDocument","getDocument","on","results","setAnnotations","data","clearAnnotations","$id","TextHighlightRules","$rules","regex","onMatch","val","stack","exec","indentationIndicator","parseInt","push","curIndent","shift","defaultToken","splice","normalizeRules"],"sourceRoot":""}