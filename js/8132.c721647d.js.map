{"version":3,"file":"js/8132.c721647d.js","mappings":"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","sources":["webpack://admin/./node_modules/ace-code/src/mode/crystal.js","webpack://admin/./node_modules/ace-code/src/mode/crystal_highlight_rules.js","webpack://admin/./node_modules/ace-code/src/mode/folding/coffee.js","webpack://admin/./node_modules/ace-code/src/mode/matching_brace_outdent.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar CrystalHighlightRules = require(\"./crystal_highlight_rules\").CrystalHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar Range = require(\"../range\").Range;\nvar FoldMode = require(\"./folding/coffee\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = CrystalHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n    this.foldingRules = new FoldMode();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n\n    this.lineCommentStart = \"#\";\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n\n        if (tokens.length && tokens[tokens.length-1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n            var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n            var startingConditional = line.match(/^\\s*(if|else|when)\\s*/);\n            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n                indent += tab;\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return /^\\s+(end|else)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, session, row) {\n        var line = session.getLine(row);\n        if (/}/.test(line))\n            return this.$outdent.autoOutdent(session, row);\n        var indent = this.$getIndent(line);\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine);\n        var tab = session.getTabString();\n        if (prevIndent.length <= indent.length) {\n            if (indent.slice(-tab.length) == tab)\n                session.remove(new Range(row, indent.length-tab.length, row, indent.length));\n        }\n    };\n\n    this.$id = \"ace/mode/crystal\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\n    var oop = require(\"../lib/oop\");\n    var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n    var CrystalHighlightRules = function () {\n\n        var builtinFunctions = (\n            \"puts|initialize|previous_def|typeof|as|pointerof|sizeof|instance_sizeof\"\n        );\n\n        var keywords = (\n            \"if|end|else|elsif|unless|case|when|break|while|next|until|def|return|class|new|getter|setter|property|lib\"\n            + \"|fun|do|struct|private|protected|public|module|super|abstract|include|extend|begin|enum|raise|yield|with\"\n            + \"|alias|rescue|ensure|macro|uninitialized|union|type|require\"\n        );\n\n        var buildinConstants = (\n            \"true|TRUE|false|FALSE|nil|NIL|__LINE__|__END_LINE__|__FILE__|__DIR__\"\n        );\n\n        var builtinVariables = (\n            \"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" +\n            \"root_url|flash|session|cookies|params|request|response|logger|self\"\n        );\n\n        var keywordMapper = this.$keywords = this.createKeywordMapper({\n            \"keyword\": keywords,\n            \"constant.language\": buildinConstants,\n            \"variable.language\": builtinVariables,\n            \"support.function\": builtinFunctions\n        }, \"identifier\");\n\n        var hexNumber = \"(?:0[xX][\\\\dA-Fa-f]+)\";\n        var decNumber = \"(?:[0-9][\\\\d_]*)\";\n        var octNumber = \"(?:0o[0-7][0-7]*)\";\n        var binNumber = \"(?:0[bB][01]+)\";\n        var intNumber = \"(?:[+-]?)(?:\" + hexNumber + \"|\" + decNumber + \"|\" + octNumber + \"|\" + binNumber + \")(?:_?[iIuU](?:8|16|32|64))?\\\\b\";\n        var escapeExpression = /\\\\(?:[nsrtvfbae'\"\\\\]|[0-7]{3}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u{[\\da-fA-F]{1,6}})/;\n        var extEscapeExspresssion = /\\\\(?:[nsrtvfbae'\"\\\\]|[0-7]{3}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u{[\\da-fA-F]{1,6}}|u{(:?[\\da-fA-F]{2}\\s)*[\\da-fA-F]{2}})/;\n        // regexp must not have capturing parentheses. Use (?:) instead.\n        // regexps are ordered -> the first match is used\n\n        this.$rules = {\n            \"start\": [\n                {\n                    token: \"comment\",\n                    regex: \"#.*$\"\n                }, {\n                    token: \"string.regexp\",\n                    regex: \"[/]\",\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.regexp\",\n                        regex: \"[/][imx]*(?=[).,;\\\\s]|$)\",\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string.regexp\"\n                    }]\n                },\n                [{\n                    regex: \"[{}]\", onMatch: function (val, state, stack) {\n                        this.next = val == \"{\" ? this.nextState : \"\";\n                        if (val == \"{\" && stack.length) {\n                            stack.unshift(\"start\", state);\n                            return \"paren.lparen\";\n                        }\n                        if (val == \"}\" && stack.length) {\n                            stack.shift();\n                            this.next = stack.shift();\n                            if (this.next.indexOf(\"string\") != -1)\n                                return \"paren.end\";\n                        }\n                        return val == \"{\" ? \"paren.lparen\" : \"paren.rparen\";\n                    },\n                    nextState: \"start\"\n                }, {\n                    token: \"string.start\",\n                    regex: /\"/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string\",\n                        regex: /\\\\#{/\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /\"/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    token: \"string.start\",\n                    regex: /`/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string\",\n                        regex: /\\\\#{/\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /`/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"rpstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?\\(/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.start\",\n                        regex: /\\(/,\n                        push: \"rpstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /\\)/,\n                        next: \"pop\"\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"spstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?\\[/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.start\",\n                        regex: /\\[/,\n                        push: \"spstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /]/,\n                        next: \"pop\"\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"fpstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?{/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.start\",\n                        regex: /{/,\n                        push: \"fpstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /}/,\n                        next: \"pop\"\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"tpstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?</,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.start\",\n                        regex: /</,\n                        push: \"tpstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: />/,\n                        next: \"pop\"\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"ppstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?\\|/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.end\",\n                        regex: /\\|/,\n                        next: \"pop\"\n                    }, {\n                        token: \"paren.start\",\n                        regex: /#{/,\n                        push: \"start\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"rpqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]\\(/,\n                    push: [{\n                        token: \"string.start\",\n                        regex: /\\(/,\n                        push: \"rpqstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /\\)/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"spqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]\\[/,\n                    push: [{\n                        token: \"string.start\",\n                        regex: /\\[/,\n                        push: \"spqstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /]/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"fpqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]{/,\n                    push: [{\n                        token: \"string.start\",\n                        regex: /{/,\n                        push: \"fpqstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: /}/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"tpqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]</,\n                    push: [{\n                        token: \"string.start\",\n                        regex: /</,\n                        push: \"tpqstring\"\n                    }, {\n                        token: \"string.end\",\n                        regex: />/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    stateName: \"ppqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]\\|/,\n                    push: [{\n                        token: \"string.end\",\n                        regex: /\\|/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }, {\n                    token: \"string.start\",\n                    regex: /'/,\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: escapeExpression\n                    }, {\n                        token: \"string.end\",\n                        regex: /'|$/,\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string\"\n                    }]\n                }], {\n                    token: \"text\", // namespaces aren't symbols\n                    regex: \"::\"\n                }, {\n                    token: \"variable.instance\", // instance variable\n                    regex: \"@{1,2}[a-zA-Z_\\\\d]+\"\n                }, {\n                    token: \"variable.fresh\", // fresh variable\n                    regex: \"%[a-zA-Z_\\\\d]+\"\n                }, {\n                    token: \"support.class\", // class name\n                    regex: \"[A-Z][a-zA-Z_\\\\d]+\"\n                }, {\n                    token: \"constant.other.symbol\", // symbol\n                    regex: \"[:](?:(?:===|<=>|\\\\[]\\\\?|\\\\[]=|\\\\[]|>>|\\\\*\\\\*|<<|==|!=|>=|<=|!~|=~|<|\\\\+|-|\\\\*|\\\\/|%|&|\\\\||\\\\^|>|!|~)|(?:(?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?))\"\n                }, {\n                    token: \"constant.numeric\", // float\n                    regex: \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?(?:_?[fF](?:32|64))?\\\\b\"\n                }, {\n                    token: \"constant.numeric\",\n                    regex: intNumber\n                }, {\n                    token: \"constant.other.symbol\",\n                    regex: ':\"',\n                    push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"constant.other.symbol\",\n                        regex: '\"',\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"constant.other.symbol\"\n                    }]\n                }, {\n                    token: \"constant.language.boolean\",\n                    regex: \"(?:true|false)\\\\b\"\n                }, {\n                    token: \"support.function\",\n                    regex: \"(?:is_a\\\\?|nil\\\\?|responds_to\\\\?|as\\\\?)\"\n                }, {\n                    token: keywordMapper,\n                    regex: \"[a-zA-Z_$][a-zA-Z0-9_$!?]*\\\\b\"\n                }, {\n                    token: \"variable.system\",\n                    regex: \"\\\\$\\\\!|\\\\$\\\\?\"\n                }, {\n                    token: \"punctuation.separator.key-value\",\n                    regex: \"=>\"\n                }, {\n                    stateName: \"heredoc\",\n                    onMatch: function (value, currentState, stack) {\n                        var next = \"heredoc\";\n                        var tokens = value.split(this.splitRegex);\n                        stack.push(next, tokens[3]);\n                        return [\n                            {type: \"constant\", value: tokens[1]},\n                            {type: \"string\", value: tokens[2]},\n                            {type: \"support.class\", value: tokens[3]},\n                            {type: \"string\", value: tokens[4]}\n                        ];\n                    },\n                    regex: \"(<<-)([']?)([\\\\w]+)([']?)\",\n                    rules: {\n                        heredoc: [{\n                            token: \"string\",\n                            regex: \"^ +\"\n                        }, {\n                            onMatch: function (value, currentState, stack) {\n                                if (value === stack[1]) {\n                                    stack.shift();\n                                    stack.shift();\n                                    this.next = stack[0] || \"start\";\n                                    return \"support.class\";\n                                }\n                                this.next = \"\";\n                                return \"string\";\n                            },\n                            regex: \".*$\",\n                            next: \"start\"\n                        }]\n                    }\n                }, {\n                    regex: \"$\",\n                    token: \"empty\",\n                    next: function (currentState, stack) {\n                        if (stack[0] === \"heredoc\")\n                            return stack[0];\n                        return currentState;\n                    }\n                }, {\n                    token: \"punctuation.operator\",\n                    regex: /[.]\\s*(?![.])/,\n                    push: [{\n                        token : \"punctuation.operator\",\n                        regex : /[.]\\s*(?![.])/\n                    }, {\n                        token : \"support.function\",\n                        regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n                    }, {\n                        regex: \"\",\n                        token: \"empty\",\n                        next: \"pop\"\n                    }]\n                }, {\n                    token: \"keyword.operator\",\n                    regex: \"!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|\\\\?|\\\\:|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\^|\\\\|\"\n                }, {\n                    token: \"punctuation.operator\",\n                    regex: /[?:,;.]/\n                }, {\n                    token: \"paren.lparen\",\n                    regex: \"[[({]\"\n                }, {\n                    token: \"paren.rparen\",\n                    regex: \"[\\\\])}]\"\n                }, {\n                    token: \"text\",\n                    regex: \"\\\\s+\"\n                }\n            ]\n        };\n\n        this.normalizeRules();\n    };\n\n    oop.inherits(CrystalHighlightRules, TextHighlightRules);\n\n    exports.CrystalHighlightRules = CrystalHighlightRules;\n","\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    this.commentBlock = function(session, row) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        range = this.commentBlock(session, row);\n        if (range)\n            return range;\n    };\n\n    // must return \"\" if there's no fold, to enable caching\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n\n        // documentation comments\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n"],"names":["oop","require","TextMode","CrystalHighlightRules","MatchingBraceOutdent","Range","FoldMode","Mode","this","HighlightRules","$outdent","$behaviour","$defaultBehaviour","foldingRules","inherits","lineCommentStart","getNextLineIndent","state","line","tab","indent","$getIndent","tokenizedLine","getTokenizer","getLineTokens","tokens","length","type","match","startingClassOrMethod","startingDoBlock","startingConditional","checkOutdent","input","test","autoOutdent","session","row","getLine","prevLine","prevIndent","getTabString","slice","remove","$id","call","prototype","exports","TextHighlightRules","builtinFunctions","keywords","buildinConstants","builtinVariables","keywordMapper","$keywords","createKeywordMapper","hexNumber","decNumber","octNumber","binNumber","intNumber","escapeExpression","extEscapeExspresssion","$rules","token","regex","push","next","defaultToken","onMatch","val","stack","nextState","unshift","shift","indexOf","stateName","value","currentState","split","splitRegex","rules","heredoc","normalizeRules","BaseFoldMode","commentBlock","re","startLevel","search","startColumn","maxRow","getLength","startRow","endRow","level","endColumn","getFoldWidgetRange","foldStyle","range","indentationBlock","getFoldWidget","prev","nextIndent","foldWidgets","doc","column","openBracePos","findMatchingBracket","replace"],"sourceRoot":""}