{"version":3,"file":"js/3080.d6824d19.js","mappings":"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","sources":["webpack://admin/./node_modules/ace-code/src/mode/folding/ruby.js","webpack://admin/./node_modules/ace-code/src/mode/html_ruby.js","webpack://admin/./node_modules/ace-code/src/mode/html_ruby_highlight_rules.js","webpack://admin/./node_modules/ace-code/src/mode/ruby.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\n\nvar FoldMode = exports.FoldMode = function () {\n};\n\noop.inherits(FoldMode, BaseFoldMode);\n\n(function () {\n    this.indentKeywords = {\n        \"class\": 1,\n        \"def\": 1,\n        \"module\": 1,\n        \"do\": 1,\n        \"unless\": 1,\n        \"if\": 1,\n        \"while\": 1,\n        \"for\": 1,\n        \"until\": 1,\n        \"begin\": 1,\n        \"else\": 0,\n        \"elsif\": 0,\n        \"rescue\": 0,\n        \"ensure\": 0,\n        \"when\": 0,\n        \"end\": -1,\n        \"case\": 1,\n        \"=begin\": 1,\n        \"=end\": -1\n    };\n\n    this.foldingStartMarker = /(?:\\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\\b|({\\s*$)|(=begin)/;\n    this.foldingStopMarker = /(=end(?=$|\\s.*$))|(^\\s*})|\\b(end)\\b/;\n\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n\n        if (isStart && !isEnd) {\n            var match = line.match(this.foldingStartMarker);\n            if (match[1]) {\n                if (match[1] == \"if\" || match[1] == \"else\" || match[1] == \"while\" || match[1] == \"until\" || match[1] == \"unless\") {\n                    if (match[1] == \"else\" && /^\\s*else\\s*$/.test(line) === false) {\n                        return;\n                    }\n                    if (/^\\s*(?:if|else|while|until|unless)\\s*/.test(line) === false) {\n                        return;\n                    }\n                }\n\n                if (match[1] == \"when\") {\n                    if (/\\sthen\\s/.test(line) === true) {\n                        return;\n                    }\n                }\n                if (session.getTokenAt(row, match.index + 2).type === \"keyword\")\n                    return \"start\";\n            } else if (match[3]) {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return \"start\";\n            } else {\n                return \"start\";\n            }\n        }\n        if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd)\n            return \"\";\n\n        var match = line.match(this.foldingStopMarker);\n        if (match[3] === \"end\") {\n            if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                return \"end\";\n        } else if (match[1]) {\n            if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                return \"end\";\n        } else\n            return \"end\";\n    };\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1] || match[3])\n                return this.rubyBlock(session, row, match.index + 2);\n\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[3] === \"end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n\n            if (match[1] === \"=end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n\n    this.rubyBlock = function (session, row, column, tokenRange) {\n        var stream = new TokenIterator(session, row, column);\n\n        var token = stream.getCurrentToken();\n        if (!token || (token.type != \"keyword\" && token.type != \"comment.multiline\"))\n            return;\n\n        var val = token.value;\n        var line = session.getLine(row);\n        switch (token.value) {\n            case \"if\":\n            case \"unless\":\n            case \"while\":\n            case \"until\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = this.indentKeywords[val];\n                break;\n            case \"when\":\n                if (/\\sthen\\s/.test(line)) {\n                    return;\n                }\n            case \"elsif\":\n            case \"rescue\":\n            case \"ensure\":\n                var dir = 1;\n                break;\n            case \"else\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = 1;\n                break;\n            default:\n                var dir = this.indentKeywords[val];\n                break;\n        }\n\n        var stack = [val];\n        if (!dir)\n            return;\n\n        var startColumn = dir === -1 ? session.getLine(row - 1).length : session.getLine(row).length;\n        var startRow = row;\n        var ranges = [];\n        ranges.push(stream.getCurrentTokenRange());\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        if (token.type == \"comment.multiline\") {\n            while (token = stream.step()) {\n                if (token.type !== \"comment.multiline\")\n                    continue;\n                if (dir == 1) {\n                    startColumn = 6;\n                    if (token.value == \"=end\") {\n                        break;\n                    }\n                } else {\n                    if (token.value == \"=begin\") {\n                        break;\n                    }\n                }\n            }\n        } else {\n            while (token = stream.step()) {\n                var ignore = false;\n                if (token.type !== \"keyword\")\n                    continue;\n                var level = dir * this.indentKeywords[token.value];\n                line = session.getLine(stream.getCurrentTokenRow());\n                switch (token.value) {\n                    case \"do\":\n                        for (var i = stream.$tokenIndex - 1; i >= 0; i--) {\n                            var prevToken = stream.$rowTokens[i];\n                            if (prevToken && (prevToken.value == \"while\" || prevToken.value == \"until\" || prevToken.value == \"for\")) {\n                                level = 0;\n                                break;\n                            }\n                        }\n                        break;\n                    case \"else\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                        if (!checkToken.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"if\":\n                    case \"unless\":\n                    case \"while\":\n                    case \"until\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                        if (!checkToken.test(line)) {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"when\":\n                        if (/\\sthen\\s/.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                }\n\n                if (level > 0) {\n                    stack.unshift(token.value);\n                } else if (level <= 0 && ignore === false) {\n                    stack.shift();\n                    if (!stack.length) {\n                        if ((val == \"while\" || val == \"until\" || val == \"for\") && token.value != \"do\") {\n                            break;\n                        }\n                        if (token.value == \"do\" && dir == -1 && level != 0)\n                            break;\n                        if (token.value != \"do\")\n                            break;\n                    }\n\n                    if (level === 0) {\n                        stack.unshift(token.value);\n                    }\n                }\n            }\n        }\n\n        if (!token)\n            return null;\n\n        if (tokenRange) {\n            ranges.push(stream.getCurrentTokenRange());\n            return ranges;\n        }\n\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1) {\n            if (token.type === \"comment.multiline\") {\n                var endColumn = 6;\n            } else {\n                var endColumn = session.getLine(row).length;\n            }\n            return new Range(row, endColumn, startRow - 1, startColumn);\n        } else\n            return new Range(startRow, startColumn, row - 1, session.getLine(row - 1).length);\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar HtmlRubyHighlightRules = require(\"./html_ruby_highlight_rules\").HtmlRubyHighlightRules;\nvar HtmlMode = require(\"./html\").Mode;\nvar JavaScriptMode = require(\"./javascript\").Mode;\nvar CssMode = require(\"./css\").Mode;\nvar RubyMode = require(\"./ruby\").Mode;\n\nvar Mode = function() {\n    HtmlMode.call(this);   \n    this.HighlightRules = HtmlRubyHighlightRules;    \n    this.createModeDelegates({\n        \"js-\": JavaScriptMode,\n        \"css-\": CssMode,\n        \"ruby-\": RubyMode\n    });\n};\noop.inherits(Mode, HtmlMode);\n\n(function() {\n\n    this.$id = \"ace/mode/html_ruby\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\n    var oop = require(\"../lib/oop\");\n    var HtmlHighlightRules = require(\"./html_highlight_rules\").HtmlHighlightRules;\n    var RubyHighlightRules = require(\"./ruby_highlight_rules\").RubyHighlightRules;\n\n    var HtmlRubyHighlightRules = function() {\n        HtmlHighlightRules.call(this);\n\n        var startRules = [\n            {\n                regex: \"<%%|%%>\",\n                token: \"constant.language.escape\"\n            }, {\n                token : \"comment.start.erb\",\n                regex : \"<%#\",\n                push  : [{\n                    token : \"comment.end.erb\",\n                    regex: \"%>\",\n                    next: \"pop\",\n                    defaultToken:\"comment\"\n                }]\n            }, {\n                token : \"support.ruby_tag\",\n                regex : \"<%+(?!>)[-=]?\",\n                push  : \"ruby-start\"\n            }\n        ];\n\n        var endRules = [\n            {\n                token : \"support.ruby_tag\",\n                regex : \"%>\",\n                next  : \"pop\"\n            }, {\n                token: \"comment\",\n                regex: \"#(?:[^%]|%[^>])*\"\n            }\n        ];\n\n        for (var key in this.$rules)\n            this.$rules[key].unshift.apply(this.$rules[key], startRules);\n\n        this.embedRules(RubyHighlightRules, \"ruby-\", endRules, [\"start\"]);\n\n        this.normalizeRules();\n    };\n\n\n    oop.inherits(HtmlRubyHighlightRules, HtmlHighlightRules);\n\n    exports.HtmlRubyHighlightRules = HtmlRubyHighlightRules;\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar RubyHighlightRules = require(\"./ruby_highlight_rules\").RubyHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar Range = require(\"../range\").Range;\nvar FoldMode = require(\"./folding/ruby\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = RubyHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n    this.foldingRules = new FoldMode();\n    this.indentKeywords = this.foldingRules.indentKeywords;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n\n    this.lineCommentStart = \"#\";\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n\n        if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n            var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n            var startingConditional = line.match(/^\\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\\s*/);\n            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n                indent += tab;\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return /^\\s+(end|else|rescue|ensure)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, session, row) {\n        var line = session.getLine(row);\n        if (/}/.test(line))\n            return this.$outdent.autoOutdent(session, row);\n        var indent = this.$getIndent(line);\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine);\n        var tab = session.getTabString();\n        if (prevIndent.length <= indent.length) {\n            if (indent.slice(-tab.length) == tab)\n                session.remove(new Range(row, indent.length - tab.length, row, indent.length));\n        }\n    };\n\n    this.getMatching = function(session, row, column) {\n        if (row == undefined) {\n            var pos = session.selection.lead;\n            column = pos.column;\n            row = pos.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        if (startToken && startToken.value in this.indentKeywords)\n            return this.foldingRules.rubyBlock(session, row, column, true);\n    };\n\n    this.$id = \"ace/mode/ruby\";\n    this.snippetFileId = \"ace/snippets/ruby\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n"],"names":["require","oop","BaseFoldMode","Range","TokenIterator","FoldMode","exports","inherits","this","indentKeywords","foldingStartMarker","foldingStopMarker","getFoldWidget","session","foldStyle","row","line","getLine","isStart","test","isEnd","match","getTokenAt","index","type","getFoldWidgetRange","doc","exec","rubyBlock","openingBracketBlock","closingBracketBlock","length","column","tokenRange","stream","token","getCurrentToken","val","value","checkToken","RegExp","dir","stack","startColumn","startRow","ranges","push","getCurrentTokenRange","step","stepBackward","stepForward","ignore","level","getCurrentTokenRow","i","$tokenIndex","prevToken","$rowTokens","unshift","shift","endColumn","call","prototype","HtmlRubyHighlightRules","HtmlMode","JavaScriptMode","CssMode","RubyMode","Mode","HighlightRules","createModeDelegates","$id","HtmlHighlightRules","RubyHighlightRules","startRules","regex","next","defaultToken","endRules","key","$rules","apply","embedRules","normalizeRules","TextMode","MatchingBraceOutdent","$outdent","$behaviour","$defaultBehaviour","foldingRules","lineCommentStart","getNextLineIndent","state","tab","indent","$getIndent","tokenizedLine","getTokenizer","getLineTokens","tokens","startingClassOrMethod","startingDoBlock","startingConditional","checkOutdent","input","autoOutdent","prevLine","prevIndent","getTabString","slice","remove","getMatching","undefined","pos","selection","lead","startToken","snippetFileId"],"sourceRoot":""}