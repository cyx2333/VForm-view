{"version":3,"file":"js/5506.dfbac476.js","mappings":"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","sources":["webpack://admin/./node_modules/ace-code/src/mode/ejs.js","webpack://admin/./node_modules/ace-code/src/mode/folding/ruby.js","webpack://admin/./node_modules/ace-code/src/mode/ruby.js"],"sourcesContent":["\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar HtmlHighlightRules = require(\"./html_highlight_rules\").HtmlHighlightRules;\nvar JavaScriptHighlightRules = require(\"./javascript_highlight_rules\").JavaScriptHighlightRules;\n\nvar EjsHighlightRules = function(start, end) {\n    HtmlHighlightRules.call(this);\n    \n    if (!start)\n        start = \"(?:<%|<\\\\?|{{)\";\n    if (!end)\n        end = \"(?:%>|\\\\?>|}})\";\n\n    for (var i in this.$rules) {\n        this.$rules[i].unshift({\n            token : \"markup.list.meta.tag\",\n            regex : start + \"(?![>}])[-=]?\",\n            push  : \"ejs-start\"\n        });\n    }\n    \n    this.embedRules(new JavaScriptHighlightRules({jsx: false}).getRules(), \"ejs-\", [{\n        token : \"markup.list.meta.tag\",\n        regex : \"-?\" + end,\n        next  : \"pop\"\n    }, {\n        token: \"comment\",\n        regex: \"//.*?\" + end,\n        next: \"pop\"\n    }]);\n    \n    this.normalizeRules();\n};\n\n\noop.inherits(EjsHighlightRules, HtmlHighlightRules);\n\nexports.EjsHighlightRules = EjsHighlightRules;\n\n\nvar oop = require(\"../lib/oop\");\nvar HtmlMode = require(\"./html\").Mode;\nvar JavaScriptMode = require(\"./javascript\").Mode;\nvar CssMode = require(\"./css\").Mode;\nvar RubyMode = require(\"./ruby\").Mode;\n\nvar Mode = function() {\n    HtmlMode.call(this);\n    this.HighlightRules = EjsHighlightRules;    \n    this.createModeDelegates({\n        \"js-\": JavaScriptMode,\n        \"css-\": CssMode,\n        \"ejs-\": JavaScriptMode\n    });\n};\noop.inherits(Mode, HtmlMode);\n\n(function() {\n\n    this.$id = \"ace/mode/ejs\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n","\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\n\nvar FoldMode = exports.FoldMode = function () {\n};\n\noop.inherits(FoldMode, BaseFoldMode);\n\n(function () {\n    this.indentKeywords = {\n        \"class\": 1,\n        \"def\": 1,\n        \"module\": 1,\n        \"do\": 1,\n        \"unless\": 1,\n        \"if\": 1,\n        \"while\": 1,\n        \"for\": 1,\n        \"until\": 1,\n        \"begin\": 1,\n        \"else\": 0,\n        \"elsif\": 0,\n        \"rescue\": 0,\n        \"ensure\": 0,\n        \"when\": 0,\n        \"end\": -1,\n        \"case\": 1,\n        \"=begin\": 1,\n        \"=end\": -1\n    };\n\n    this.foldingStartMarker = /(?:\\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\\b|({\\s*$)|(=begin)/;\n    this.foldingStopMarker = /(=end(?=$|\\s.*$))|(^\\s*})|\\b(end)\\b/;\n\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n\n        if (isStart && !isEnd) {\n            var match = line.match(this.foldingStartMarker);\n            if (match[1]) {\n                if (match[1] == \"if\" || match[1] == \"else\" || match[1] == \"while\" || match[1] == \"until\" || match[1] == \"unless\") {\n                    if (match[1] == \"else\" && /^\\s*else\\s*$/.test(line) === false) {\n                        return;\n                    }\n                    if (/^\\s*(?:if|else|while|until|unless)\\s*/.test(line) === false) {\n                        return;\n                    }\n                }\n\n                if (match[1] == \"when\") {\n                    if (/\\sthen\\s/.test(line) === true) {\n                        return;\n                    }\n                }\n                if (session.getTokenAt(row, match.index + 2).type === \"keyword\")\n                    return \"start\";\n            } else if (match[3]) {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return \"start\";\n            } else {\n                return \"start\";\n            }\n        }\n        if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd)\n            return \"\";\n\n        var match = line.match(this.foldingStopMarker);\n        if (match[3] === \"end\") {\n            if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                return \"end\";\n        } else if (match[1]) {\n            if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                return \"end\";\n        } else\n            return \"end\";\n    };\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1] || match[3])\n                return this.rubyBlock(session, row, match.index + 2);\n\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[3] === \"end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n\n            if (match[1] === \"=end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n\n    this.rubyBlock = function (session, row, column, tokenRange) {\n        var stream = new TokenIterator(session, row, column);\n\n        var token = stream.getCurrentToken();\n        if (!token || (token.type != \"keyword\" && token.type != \"comment.multiline\"))\n            return;\n\n        var val = token.value;\n        var line = session.getLine(row);\n        switch (token.value) {\n            case \"if\":\n            case \"unless\":\n            case \"while\":\n            case \"until\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = this.indentKeywords[val];\n                break;\n            case \"when\":\n                if (/\\sthen\\s/.test(line)) {\n                    return;\n                }\n            case \"elsif\":\n            case \"rescue\":\n            case \"ensure\":\n                var dir = 1;\n                break;\n            case \"else\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = 1;\n                break;\n            default:\n                var dir = this.indentKeywords[val];\n                break;\n        }\n\n        var stack = [val];\n        if (!dir)\n            return;\n\n        var startColumn = dir === -1 ? session.getLine(row - 1).length : session.getLine(row).length;\n        var startRow = row;\n        var ranges = [];\n        ranges.push(stream.getCurrentTokenRange());\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        if (token.type == \"comment.multiline\") {\n            while (token = stream.step()) {\n                if (token.type !== \"comment.multiline\")\n                    continue;\n                if (dir == 1) {\n                    startColumn = 6;\n                    if (token.value == \"=end\") {\n                        break;\n                    }\n                } else {\n                    if (token.value == \"=begin\") {\n                        break;\n                    }\n                }\n            }\n        } else {\n            while (token = stream.step()) {\n                var ignore = false;\n                if (token.type !== \"keyword\")\n                    continue;\n                var level = dir * this.indentKeywords[token.value];\n                line = session.getLine(stream.getCurrentTokenRow());\n                switch (token.value) {\n                    case \"do\":\n                        for (var i = stream.$tokenIndex - 1; i >= 0; i--) {\n                            var prevToken = stream.$rowTokens[i];\n                            if (prevToken && (prevToken.value == \"while\" || prevToken.value == \"until\" || prevToken.value == \"for\")) {\n                                level = 0;\n                                break;\n                            }\n                        }\n                        break;\n                    case \"else\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                        if (!checkToken.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"if\":\n                    case \"unless\":\n                    case \"while\":\n                    case \"until\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                        if (!checkToken.test(line)) {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"when\":\n                        if (/\\sthen\\s/.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                }\n\n                if (level > 0) {\n                    stack.unshift(token.value);\n                } else if (level <= 0 && ignore === false) {\n                    stack.shift();\n                    if (!stack.length) {\n                        if ((val == \"while\" || val == \"until\" || val == \"for\") && token.value != \"do\") {\n                            break;\n                        }\n                        if (token.value == \"do\" && dir == -1 && level != 0)\n                            break;\n                        if (token.value != \"do\")\n                            break;\n                    }\n\n                    if (level === 0) {\n                        stack.unshift(token.value);\n                    }\n                }\n            }\n        }\n\n        if (!token)\n            return null;\n\n        if (tokenRange) {\n            ranges.push(stream.getCurrentTokenRange());\n            return ranges;\n        }\n\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1) {\n            if (token.type === \"comment.multiline\") {\n                var endColumn = 6;\n            } else {\n                var endColumn = session.getLine(row).length;\n            }\n            return new Range(row, endColumn, startRow - 1, startColumn);\n        } else\n            return new Range(startRow, startColumn, row - 1, session.getLine(row - 1).length);\n    };\n\n}).call(FoldMode.prototype);\n","\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar RubyHighlightRules = require(\"./ruby_highlight_rules\").RubyHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar Range = require(\"../range\").Range;\nvar FoldMode = require(\"./folding/ruby\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = RubyHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n    this.foldingRules = new FoldMode();\n    this.indentKeywords = this.foldingRules.indentKeywords;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n\n    this.lineCommentStart = \"#\";\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n\n        if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n            var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n            var startingConditional = line.match(/^\\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\\s*/);\n            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n                indent += tab;\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return /^\\s+(end|else|rescue|ensure)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, session, row) {\n        var line = session.getLine(row);\n        if (/}/.test(line))\n            return this.$outdent.autoOutdent(session, row);\n        var indent = this.$getIndent(line);\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine);\n        var tab = session.getTabString();\n        if (prevIndent.length <= indent.length) {\n            if (indent.slice(-tab.length) == tab)\n                session.remove(new Range(row, indent.length - tab.length, row, indent.length));\n        }\n    };\n\n    this.getMatching = function(session, row, column) {\n        if (row == undefined) {\n            var pos = session.selection.lead;\n            column = pos.column;\n            row = pos.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        if (startToken && startToken.value in this.indentKeywords)\n            return this.foldingRules.rubyBlock(session, row, column, true);\n    };\n\n    this.$id = \"ace/mode/ruby\";\n    this.snippetFileId = \"ace/snippets/ruby\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n"],"names":["oop","require","HtmlHighlightRules","JavaScriptHighlightRules","EjsHighlightRules","start","end","i","call","this","$rules","unshift","token","regex","push","embedRules","jsx","getRules","next","normalizeRules","inherits","exports","HtmlMode","JavaScriptMode","CssMode","Mode","HighlightRules","createModeDelegates","$id","prototype","BaseFoldMode","Range","TokenIterator","FoldMode","indentKeywords","foldingStartMarker","foldingStopMarker","getFoldWidget","session","foldStyle","row","line","getLine","isStart","test","isEnd","match","getTokenAt","index","type","getFoldWidgetRange","doc","exec","rubyBlock","openingBracketBlock","closingBracketBlock","length","column","tokenRange","stream","getCurrentToken","val","value","checkToken","RegExp","dir","stack","startColumn","startRow","ranges","getCurrentTokenRange","step","stepBackward","stepForward","ignore","level","getCurrentTokenRow","$tokenIndex","prevToken","$rowTokens","shift","endColumn","TextMode","RubyHighlightRules","MatchingBraceOutdent","$outdent","$behaviour","$defaultBehaviour","foldingRules","lineCommentStart","getNextLineIndent","state","tab","indent","$getIndent","tokenizedLine","getTokenizer","getLineTokens","tokens","startingClassOrMethod","startingDoBlock","startingConditional","checkOutdent","input","autoOutdent","prevLine","prevIndent","getTabString","slice","remove","getMatching","undefined","pos","selection","lead","startToken","snippetFileId"],"sourceRoot":""}